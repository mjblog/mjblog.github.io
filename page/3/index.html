<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>mjblog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="mjblog">
<meta property="og:url" content="http://mjblog.github.io/page/3/index.html">
<meta property="og:site_name" content="mjblog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ma Jiang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="mjblog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">mjblog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mjblog.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-nvidia_compiler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/16/nvidia_compiler/" class="article-date">
  <time datetime="2020-03-16T03:17:32.000Z" itemprop="datePublished">2020-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/16/nvidia_compiler/">nvidia gpu编译器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/16/nvidia_compiler/" data-id="cknykihln0019otfahhucgbvh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr10_conclusion" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/llvm_tr10_conclusion/" class="article-date">
  <time datetime="2020-03-13T09:12:57.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/llvm_tr10_conclusion/">Kaleidoscope conclusion</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="总结本次实现待改进点："><a href="#总结本次实现待改进点：" class="headerlink" title="总结本次实现待改进点："></a>总结本次实现待改进点：</h3><p>基本功能：<br>1 补充测试用例（lexer，loc等）,新增系统测试以覆盖更复杂的场景（可以直接参考llvm代码中的test/Examples/Kaleidoscope/Chapter4.test）<br>2 loc中filename冗余消除<br>3 ast的dump功能<br>4 智能指针的使用改进，shared_ptr是否能转回unique？能否实现自动类型转换，避免大量的get？<br>5 添加简单的入参解析流程，help信息改进<br>6 建立行缓冲，在遇到解析错误时，把错误行打印出来，帮助调试<br>7 头文件中using namespace，可能导致污染，需要去掉。<br>8 调试信息bugfix，var/for中的变量还未进行声明，operator = 的信息生成还有问题 (已修复)<br>9 尝试接入方舟的Maple IR，尝试实现Vistor模式<br>…<br>把教程中的一些严重问题，如for的语义，调试信息不正确的问题邮件反馈。</p>
<h3 id="新的有趣扩展"><a href="#新的有趣扩展" class="headerlink" title="新的有趣扩展"></a>新的有趣扩展</h3><p>1 添加global variables实现<br>2 添加类型系统typed variables<br>3 添加arrays, structs, vectors的支持，练习LLVM getelementptr instruction的使用<br>3 实现辅助的runtime功能，例如IO？<br>4 内存管理memory management<br>5 异常支持exception handling support </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/13/llvm_tr10_conclusion/" data-id="cknykihl5000notfa56oy5pt9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr9_debug_info" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/llvm_tr9_debug_info/" class="article-date">
  <time datetime="2020-03-10T11:52:05.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/llvm_tr9_debug_info/">Kaleidoscope debug info</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 调试信息生成时，提到Kaleidoscope语言的abi接近C的abi。从哪里可以明确这一点？</p>
<p>2  source_loc的实现是否合理？有无改进空间？<br>string的存储？</p>
<p>3 能否将core_lib中的operator 先放到parser中解析，完成后再解析输入的用户文件？通过合并ast后再codegen，应该可以静默的实现语言扩展的operator。</p>
<p>4 var变量中的变量是否正确生成了调试信息</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>为减少工作了，剔除原示例悄悄添加的ast dump功能（文字没有介绍，代码新增了）。<br>实现了debug信息的添加，并修复了原实现中的逻辑错误。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现中的主要改动如下：</p>
<p>1 出于节约工作量考虑，删除了原示例中的AST的dump功能，暂未实现；</p>
<p>2<br>原文实现时的调试信息发射有问题，会导致部分指令的调试信息错误。<br>如下binary op的发射代码所示，原示例在函数头部emitLocation，其信息会马上被随后的LHS/RHS codegen覆盖（他们也会emitLocation）。这样一来，真正属于operator的CreateFAdd指令会位于最后一个emitLocation指向的location(也就是RHS的location)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  KSDbgInfo.emitLocation(<span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">"addtmp"</span>);</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用如下的方法编译llvm中的示例代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd llvm-project&#x2F;llvm&#x2F;examples&#x2F;Kaleidoscope&#x2F;Chapter9</span><br><span class="line"> g++ toy.cpp -I ..&#x2F;include&#x2F; -I ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;install&#x2F;usr&#x2F;local&#x2F;include&#x2F; -L..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;install&#x2F;usr&#x2F;local&#x2F;lib &#96;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;install&#x2F;usr&#x2F;local&#x2F;bin&#x2F;llvm-config --libs&#96; -pthread -ldl  -lz -ltinfo -fno-rtti -o toy</span><br></pre></td></tr></table></figure>
<p>然后用下面的测试代码测试toy程序(输入后ctrl+D结束程序)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def binary , 1 (left  right) right</span><br><span class="line"></span><br><span class="line">extern kout(x)</span><br><span class="line">def te(y)</span><br><span class="line">kout(y),</span><br><span class="line">y&#x3D;5,</span><br><span class="line">kout(y)</span><br><span class="line"></span><br><span class="line">def main()</span><br><span class="line">	te(2)</span><br></pre></td></tr></table></figure>
<p>可以获得其输出的LLVM-IR打印如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">define double @te(double %y) !dbg !13 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %y1 &#x3D; alloca double</span><br><span class="line">  call void @llvm.dbg.declare(metadata double* %y1, metadata !17, metadata !DIExpression()), !dbg !18</span><br><span class="line">  store double %y, double* %y1</span><br><span class="line">  %y2 &#x3D; load double, double* %y1, !dbg !19</span><br><span class="line">  %calltmp &#x3D; call double @kout(double %y2), !dbg !19</span><br><span class="line">  store double 5.000000e+00, double* %y1, !dbg !20</span><br><span class="line">  %binop &#x3D; call double @&quot;binary,&quot;(double %calltmp, double 5.000000e+00), !dbg !20</span><br><span class="line">  %y3 &#x3D; load double, double* %y1, !dbg !21</span><br><span class="line">  %calltmp4 &#x3D; call double @kout(double %y3), !dbg !21</span><br><span class="line">  %binop5 &#x3D; call double @&quot;binary,&quot;(double %binop, double %calltmp4), !dbg !21</span><br><span class="line">  ret double %binop5, !dbg !21</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">!13 &#x3D; distinct !DISubprogram(name: &quot;te&quot;, scope: !2, </span><br><span class="line">!20 &#x3D; !DILocation(line: 6, column: 3, scope: !13)</span><br><span class="line">!21 &#x3D; !DILocation(line: 7, column: 6, scope: !13)</span><br></pre></td></tr></table></figure>
<p>可以看到te函数中的两个’,’ operator，其对应的行号都指向了rhs的位置，完全和源代码对不上。<br>使用我们的实现编译代码（因为已经内置了’,’，去掉了其定义）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extern kout(x)</span><br><span class="line"></span><br><span class="line">def te(y)</span><br><span class="line">kout(y),</span><br><span class="line">y&#x3D;5,</span><br><span class="line">kout(y)</span><br><span class="line"></span><br><span class="line">def main()</span><br><span class="line">	te(2)</span><br></pre></td></tr></table></figure>
<p>获得的输出如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">efine double @te(double %y) !dbg !3 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %y1 &#x3D; alloca double</span><br><span class="line">  store double %y, double* %y1, !dbg !9</span><br><span class="line">  call void @llvm.dbg.declare(metadata double* %y1, metadata !8, metadata !DIExpression()), !dbg !10</span><br><span class="line">  %y2 &#x3D; load double, double* %y1, !dbg !11</span><br><span class="line">  %callkout &#x3D; call double @kout(double %y2), !dbg !12</span><br><span class="line">  store double 5.000000e+00, double* %y1, !dbg !13</span><br><span class="line">  %&quot;_binary_,_with_prio_1&quot; &#x3D; call double @&quot;_binary_,_with_prio_1&quot;(double %callkout, double 5.000000e+00), !dbg !12</span><br><span class="line">  %y3 &#x3D; load double, double* %y1, !dbg !14</span><br><span class="line">  %callkout4 &#x3D; call double @kout(double %y3), !dbg !15</span><br><span class="line">  %&quot;_binary_,_with_prio_15&quot; &#x3D; call double @&quot;_binary_,_with_prio_1&quot;(double %&quot;_binary_,_with_prio_1&quot;, double %callkout4), !dbg !13</span><br><span class="line">  ret double %&quot;_binary_,_with_prio_15&quot;, !dbg !13</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">!3 &#x3D; distinct !DISubprogram(name: &quot;te&quot;, scope: !1, file: !1, line: 3, type: !4, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !7)</span><br><span class="line">...</span><br><span class="line">!12 &#x3D; !DILocation(line: 4, column: 8, scope: !3)</span><br><span class="line">!13 &#x3D; !DILocation(line: 5, column: 4, scope: !3)</span><br></pre></td></tr></table></figure>
<p>可以看到，修正后’,’的位置(参考)可以与源代码吻合。<br>  %”<em>binary</em>,<em>with_prio_1” = call double @”_binary</em>,_with_prio_1”(double %callkout, double 5.000000e+00), !dbg !12 这里说明第一个’,’的location在!dbg !12中给出。<br>  而!12 = !DILocation(line: 4, column: 8, scope: !3)准确给出了，’,’在代码的第4行第8列(scope: !3可以继续看到其属于te函数)。</p>
<p>3 为token也添加了location信息，ast的location从token中获取，不直接与lexer打交道层级更清晰。</p>
<p>4 新增了调试信息发射的控制流程和开关变量</p>
<p>5<br>在发射函数的IR时，我们的实现为了方便控制调试信息的发射，<br>将调试信息的发射拆分成了两块。args的调试信息在args的store指令之后发射。<br>这会导致verifyFunction是发生下面错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Expected no forward declarations!</span><br><span class="line">!6 &#x3D; &lt;temporary!&gt; !&#123;&#125;</span><br><span class="line">  store double %x, double* %x1, !dbg !7</span><br><span class="line">  store double %y, double* %y2, !dbg !7</span><br><span class="line">  call void @llvm.dbg.declare(metadata double* %x1, metadata !8, metadata !DIExpression()), !dbg !9</span><br><span class="line">  call void @llvm.dbg.declare(metadata double* %y2, metadata !10, metadata !DIExpression()), !dbg !9</span><br></pre></td></tr></table></figure>
<p>使用 def foo (x y) x+y即可复现。<br>看起来dbg.declare需要放到对应store指令的前面。<br>参考<a href="https://stackoverflow.com/questions/34236034/how-to-track-down-llvm-verifyfunction-error-expected-no-forward-declarations/60656058#60656058后，" target="_blank" rel="noopener">https://stackoverflow.com/questions/34236034/how-to-track-down-llvm-verifyfunction-error-expected-no-forward-declarations/60656058#60656058后，</a><br>在添加verifyFunction前添加finalizeSubprogram，可更正错误。</p>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 调试信息生成时，提到Kaleidoscope语言的abi接近C的abi。从哪里可以明确这一点？<br>语言目前没有明确设计ABI，在LLVM-IR的生成过程中，其实也不需要配置这些内容。当需要具体生成代码时，LLVM的处理流程会用默认值来工作。对于函数的 calling conventions 来说，可以用setCallingConv方法来专门进行设置。通过追踪设置函数可以看到，其初始值应该为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setCallingConv</span><span class="params">(CallingConv::ID CC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ID = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(CC);</span><br><span class="line">    assert(!(ID &amp; ~CallingConv::MaxID) &amp;&amp; <span class="string">"Unsupported calling convention"</span>);</span><br><span class="line">    setValueSubclassData((getSubclassDataFromValue() &amp; <span class="number">0xc00f</span>) | (ID &lt;&lt; <span class="number">4</span>));</span><br><span class="line">  &#125;</span><br><span class="line">---&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValueSubclassData</span><span class="params">(<span class="keyword">unsigned</span> short D)</span> </span>&#123;</span><br><span class="line">    Value::setValueSubclassData(D);</span><br><span class="line">  &#125;</span><br><span class="line">---&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValueSubclassData</span><span class="params">(<span class="keyword">unsigned</span> short D)</span> </span>&#123; SubclassData = D; &#125;</span><br><span class="line">---&gt;</span><br><span class="line">  <span class="comment">/// Hold arbitrary subclass data.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This member is defined by this class, but is not used for anything.</span></span><br><span class="line">  <span class="comment">/// Subclasses can use it to hold whatever state they find useful.  This</span></span><br><span class="line">  <span class="comment">/// field iweizhis initialized to zero by the ctor.</span></span><br><span class="line">  <span class="keyword">unsigned</span> short SubclassData;</span><br></pre></td></tr></table></figure>
<p>  0值对应的意义可以在llvm/IR/CallingConv.h中找到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A set of enums which specify the assigned numeric values for known llvm</span></span><br><span class="line"><span class="comment">/// calling conventions.</span></span><br><span class="line"><span class="comment">/// LLVM Calling Convention Representation</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  <span class="comment">/// C - The default llvm calling convention, compatible with C.  This</span></span><br><span class="line">  <span class="comment">/// convention is the only calling convention that supports varargs calls.</span></span><br><span class="line">  <span class="comment">/// As with typical C calling conventions, the callee/caller have to</span></span><br><span class="line">  <span class="comment">/// tolerate certain amounts of prototype mismatch.</span></span><br><span class="line">  C = <span class="number">0</span>,</span><br></pre></td></tr></table></figure>
<p>这样看起来，原文的说法是基本正确的。在没有设置ABI的情况下，LLVM应该是用了C的配置作为默认值。</p>
<p>2  source_loc的实现是否合理？有无改进空间？<br>为了简单，source_loc当前存在大量的冗余信息。<br>至少其中大量重复的filename string应该合并到一个上，改用idx指向一个vector。<br>最终的方案可能是参考gcc等成熟编译器，将source_loc整个设计为一个idx，要取用的时候再组装成完整的信息。内部储存时，可以合并冗余的string，甚至还可以进一步采用压缩编码方式来记录行号和列号(例如使用基础值+偏移值的方式来记录)。</p>
<p>3 能否将core_lib中的operator 先放到parser中解析，完成后再解析输入的用户文件？通过合并ast后再codegen，应该可以静默的实现语言扩展的operator。<br>可以，但是不能通过合并ast来实现。<br>当前用户自定义operator的功能需要lexer的支持，parse正式代码时lexer不知道新增了哪些operator，会导致unknown token的出现。<br>目前实现的方案是，在parser中静默导入了自定义operator的extern声明，这样用户可以像使用内置operator一样直接使用这些扩展operator。自定义operator的实现放到了core_support_lib中，封装脚本会链入实现。<br>当前实现的主要问题是，operator很多都是短小语句，应该inline优化的，但是拆开成库的形式后，只有lto优化才能达到效果。<br>后续可能的改进是，直接把def定义灌入parser，通过直接修改lexer的loc信息(或者先关掉调试信息输出生成operator定义部分，再codegen剩下的部分)，解决调试信息的冲突问题。</p>
<p>4 var变量中的变量是否正确生成了调试信息<br>没有，原示例var和for中的变量都没有做declare，所以没有对应的调试信息。需要参考args中的处理方法，逐个添加。<br>出于工作量考虑，本次实现也暂时还未添加这些调试信息。</p>
<h3 id="实现中遇到的问题"><a href="#实现中遇到的问题" class="headerlink" title="实现中遇到的问题"></a>实现中遇到的问题</h3><p>1 ranged loop 内部定义的变量，无法跨过循环体保存值。如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line">                &#123;<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="string">":"</span> &lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果将是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:1</span><br><span class="line">0:2</span><br><span class="line">0:3</span><br></pre></td></tr></table></figure>
<p>而不是预期的1:1,2:2,3:3。并且，打开Wall -Wextra时也没有告警。。。</p>
<p>2<br>实现时再次测试了using namespace std;在头文件中的作用范围</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> xx&#123;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;&#125;</span><br><span class="line"><span class="keyword">namespace</span> xx&#123;<span class="function"><span class="keyword">void</span> <span class="title">tt</span><span class="params">()</span> </span>&#123;<span class="built_in">string</span> x;&#125;&#125;</span><br><span class="line"><span class="keyword">namespace</span> xx1&#123;<span class="function"><span class="keyword">void</span> <span class="title">tt</span><span class="params">()</span> </span>&#123;<span class="built_in">string</span> x;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>会报如下错误。说明头文件中的using会污染和其相同的命名空间。控制using namespace的作用范围仍然是一个有意义的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tt.cpp:4:26: error: ‘string’ was not declared in this scope</span><br><span class="line"> namespace xx1&#123;void tt() &#123;string x;&#125;&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/10/llvm_tr9_debug_info/" data-id="cknykihm1001potfaa6byanl1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr8_object_generation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/llvm_tr8_object_generation/" class="article-date">
  <time datetime="2020-03-10T02:42:54.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/llvm_tr8_object_generation/">Kaleidoscope object generation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 原示例使用了通用的机器模型进行编译，能否实现针对本地机器的更细粒度优化？</p>
<p>2 能否以较低代价实现支持交叉编译?</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>完成了原示例中的功能。<br>新增了功能：针对native机器的细粒度优化（打开本地cpu支持的特性）。<br>新增了基于环境变量的选项控制功能：默认生成object文件后，可以用选项控制保留LLVM-IR中间文件。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现的两个主要变更：<br>1<br>原示例基于通用cpu的特性来生成代码，优化没有充分利用本地cpu的能力。本次实现改为了基于native去探测本地cpu的能力，选择最合适的指令（相当于使用l了-march=native）。具体实现过程使用了llvm/CodeGen/CommandFlags.inc中的getCPUStr函数来探测cpu。但是该inc文件似乎并不是一个稳定的开放接口文件，在工程内多次包含启动时会有冲突，同时其设置内部变量的方法也比较粗暴。实现时通过将其隔离到单个cpp文件来规避了该问题，可能并不是最好的解决方法。</p>
<p>2<br>添加object文件生成功能后，按照编译器的通常约定，将默认输出从LLVM-IR修改为object文件。同时，为了调试编译器本身的逻辑，查看编译过程中生成的LLVM-IR也是很有帮助的。<br>为了支持这样的控制逻辑，添加了一个基于环境变量的选项控制框架。实现代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">control_flags</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flag_item</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		T flag_val;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* input_env;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* description;</span><br><span class="line">		flag_item(T default_val, <span class="keyword">const</span> <span class="keyword">char</span>* env, <span class="keyword">const</span> <span class="keyword">char</span>* des) :</span><br><span class="line">			input_env(env), description(des)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *env_val = getenv(input_env);</span><br><span class="line">			<span class="keyword">if</span> (env_val != <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">stringstream</span> tmp;</span><br><span class="line">				tmp &lt;&lt; env_val;</span><br><span class="line">				tmp &gt;&gt; flag_val;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				flag_val = default_val;</span><br><span class="line">		&#125;</span><br><span class="line">		flag_item()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> flag_val;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECL_FLAG(flag_type, flag_name, default_val, input_env, des) \</span></span><br><span class="line">	flag_item&lt;flag_type&gt; flag_name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"flags.def"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECL_FLAG</span></span><br><span class="line">	control_flags()</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECL_FLAG(flag_type, flag_name, default_val, input_env, des) \</span></span><br><span class="line">	flag_item&lt;flag_type&gt; flag_name#<span class="meta">#cons(default_val, input_env, des);\</span></span><br><span class="line">	flag_name = flag_name##cons;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"flags.def"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECL_FLAG</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;global_flags;</span><br></pre></td></tr></table></figure>
<p>其基本思路很简单，借鉴自golang编译器的实践。从环境变量中获取输入，避开繁琐的输入选项解析。再利用sstream提供的通用类型转换功能，可以完成大多数情况下的flag数值设置。后续只需要按需增加callback函数做输入的合法性检查即可。<br>在此框架下添加控制选项只需新增如下一行即可。引用flags时，只需将定义一个全局变量 control_flags global_flag，然后引用global_flag.save_temps等名称即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量类型，变量名称，变量默认值，用于控制该变量的环境变量名称，变量作用描述</span></span><br><span class="line">DECL_FLAG(<span class="keyword">bool</span>, save_temps, <span class="literal">false</span>, <span class="string">"save_temps"</span>, <span class="string">"keep intermediate files"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 原示例使用了通用的机器模型进行编译，能否实现针对本地机器的更细粒度优化？<br>使用llvm提供的机制即可自动探测本地cpu的能力，细节可参考实现1中的描述。</p>
<p>2 能否以较低代价实现支持交叉编译?<br>llvm框架中交叉编译是默认配置，本地配置只不过一种特化场景。因此，要支持交叉编译非常容易，只需要新增一个入参指定目标代码的三元组TargetTriple(如x86_64-linux-gnu)即可。但是考虑到新增这个特性后，需要一并添加正确性检查，修改optimizer中的逻辑，工作量稍大。在完成主体工作前，可以稍缓一点实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/10/llvm_tr8_object_generation/" data-id="cknykihll0016otfaaede5taz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr7_mutable_variables" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/llvm_tr7_mutable_variables/" class="article-date">
  <time datetime="2020-03-02T13:15:01.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/llvm_tr7_mutable_variables/">Kaleidoscope mutable variable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 使用CreateAlloca在function的头部创建栈空间，是否会导致不必要的额外栈空间占用？</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>完成了原示例的功能，添加了对应的简单测试。<br>以库的方式添加了’,’和’!=’等核心的operator，尚未自动添加到源代码中。<br>一种可行的简单方式是以源代码方式直接把这些operator的def直接include到代码的头部，然后再编译。但是，需要考虑这样操作对源代码行号的干扰。<br>等待后续生成调试信息的章节一并考虑。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现时做了如下两个主要的改进:<br>1 var中变量默认数值设置为0，原示例是在LLVM-IR 生成时构造的。从逻辑上看，这个应该是语法层面的规定，不应该放到codegen的流程中决定。本次实现时，在parser中parse_var时将未初始化的变量value设置为了0。codegen时只管按值生成就可以了。<br>2 在处理var中的变量shadow前面已定义变量的情况时。原示例为了简单，是直接把var中声明的所有变量都缓冲到了OldBindings中，如果没有shadow，则把nullptr缓冲到OldBindings中。生成完body后，直接把OldBindings中的所有条目写回NamedValues中。如下片段所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;AllocaInst *&gt; OldBindings;</span><br><span class="line">  OldBindings.push_back(NamedValues[VarName]);</span><br><span class="line">  <span class="comment">// Remember this binding.</span></span><br><span class="line">  NamedValues[VarName] = Alloca;</span><br><span class="line">....body_gen....</span><br><span class="line">  <span class="comment">// Pop all our variables from scope.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = VarNames.<span class="built_in">size</span>(); i != e; ++i)</span><br><span class="line">    NamedValues[VarNames[i].first] = OldBindings[i];</span><br></pre></td></tr></table></figure>
<p>本次实现使用了更安全的find来替代[] operator，同时改进了缓存结构。<br>通过存储named_var中被shadow变量alloca字段的地址，消除了恢复<br>named_var时的map查找动作，如下片段所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;AllocaInst **, AllocaInst *&gt;&gt; saved_name_vec;</span><br><span class="line">....</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = named_var.<span class="built_in">find</span>(var_name); it != named_var.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			saved_name_vec.push_back(</span><br><span class="line">				<span class="built_in">std</span>::make_pair(&amp;(it-&gt;second), it-&gt;second));</span><br><span class="line">			it-&gt;second = var_allocas[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			named_var[var_name] = var_allocas[i];</span><br><span class="line">	&#125;</span><br><span class="line">...bodygen....</span><br><span class="line"><span class="comment">//恢复named_var</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; saved_name_vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> old_alloca_addr = saved_name_vec[i].first;</span><br><span class="line">		*old_alloca_addr = saved_name_vec[i].second;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3 实现测试时发现了原示例中存在内存泄漏的可能，如下代码所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">IfExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// Create blocks for the then and else cases.  Insert the 'then' block at the</span></span><br><span class="line">  <span class="comment">// end of the function.</span></span><br><span class="line">  BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class="string">"then"</span>, TheFunction);</span><br><span class="line">  BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class="string">"else"</span>);</span><br><span class="line">  BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class="string">"ifcont"</span>);</span><br><span class="line">....</span><br><span class="line">  Value *ThenV = Then-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!ThenV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码片段中，ElseBB和MergeBB创建后没有立即挂入function的链表中。如果函数在类似于ThenV的异常流程中return了，则没有人能释放掉这两个指针了。我们的实现中也有类似问题。<br>要比较完整的修复该问题，有两个点需要同时考虑：<br>首先，BB创建后都立即挂到Function中去是否会有不良影响？如果没有，创建就挂上是最好的解决方案；<br>如果不能立即挂上，除了在函数内考虑释放资源外，还要考虑    ir_builder.CreateBr(merge_bb);等语句在异常发生时可能引用悬空指针的问题。需要重排对这些指针的引用，将其都放到末尾。</p>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 使用CreateAlloca在function的头部创建栈空间，是否会导致不必要的额外栈空间占用？<br>使用如下的c语言片段进行了测试。发现clang生成代码时也会把alloca都放到头部，并且生成的x86-64和mips64的代码也都是一次在头部把sp预留够。<br>这里的权衡可能是动态扩展栈变量无法节约多少内存，但是会浪费操作sp的指令，另外也使得分析stack frame变得更为困难，得不偿失。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (x)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">char</span> nb[<span class="number">1024</span>]= &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现中遇到的问题"><a href="#实现中遇到的问题" class="headerlink" title="实现中遇到的问题"></a>实现中遇到的问题</h3><p>1 map 的operator[]会改写原map<br>在改写for代码生成流程中，named_var map 记录和恢复idt var的部分时，<br>注意到了下面一对代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">auto</span> old_val = named_var[idt_name];</span><br><span class="line">	named_var[idt_name] = idt_var;</span><br><span class="line">.....</span><br><span class="line">	<span class="keyword">if</span> (old_val != <span class="literal">nullptr</span>)</span><br><span class="line">		named_var[idt_name] = old_val;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		named_var.erase(idt_name);</span><br></pre></td></tr></table></figure>
<p>这段逻辑是直接从原示例中拷贝过来的。<br>重构时注意到named_var[idt_name]的初始值问题。<br>当idt_name这个key不在map中时，读取其value的语义是比较模糊的。<br>参考<a href="https://en.cppreference.com/w/cpp/container/map/operator_at" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/container/map/operator_at</a> ， 发现[]这个operator竟然会静默的insert，即使这个operator是用在取右值的动作中。<br>用下面的示例，可以较为直观展示出这个出人意料的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>*&gt; t1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size before access:"</span> &lt;&lt; t1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"uninitialized pointer is: "</span> &lt;&lt; t1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size after access:"</span> &lt;&lt; t1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"count after access:"</span> &lt;&lt; t1.count(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的输出如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size before access:0</span><br><span class="line">uninitialized pointer is: 0</span><br><span class="line">size after access:1</span><br><span class="line">count after access:1</span><br></pre></td></tr></table></figure>
<p>可以看到使用[]访问map时，确实会有insert的动作，并且当key不在map中时，返回的vale是一个默认初始化的值。<br>在这样的语义下，原示例的代码片段虽然不会导致严重的逻辑错误，但是仍有两个明显的问题。<br>第一，引入了冗余的insert动作，拖慢了编译器工作速度。<br>第二，在退出清理map时，如果初始key不存在就不会erase。这样一来map中会残留一个错误的映射项目idt_var –&gt; nullptr。后续流程如果直接使用count这类存在性接口去测试，会得到错误的结果。这是一个潜在的错误来源。</p>
<p>2 std::move作用于const vector不生效<br>如下测试代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testc_ref</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inner;</span><br><span class="line">    testc_ref(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in) : inner(<span class="built_in">std</span>::<span class="built_in">move</span>(in)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testc_move</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inner;</span><br><span class="line">    testc_move(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in) : inner(<span class="built_in">std</span>::<span class="built_in">move</span>(in)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testc_const_ref</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inner;</span><br><span class="line">    testc_const_ref(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in) : inner(<span class="built_in">std</span>::<span class="built_in">move</span>(in)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mytest</span><span class="params">(<span class="number">100000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"org:"</span> &lt;&lt; &amp;(mytest[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">testc_move <span class="title">t1</span><span class="params">(mytest)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1:"</span>&lt;&lt; &amp;(t1.inner[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;(mytest[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">testc_move <span class="title">t2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(mytest))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t2:"</span>&lt;&lt; &amp;(t2.inner[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;(mytest[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mytest1</span><span class="params">(<span class="number">100000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"org:"</span> &lt;&lt; &amp;(mytest1[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">testc_ref <span class="title">t3</span><span class="params">(mytest1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t3:"</span>&lt;&lt; &amp;(t3.inner[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;(mytest1[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mytest2</span><span class="params">(<span class="number">100000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"org:"</span> &lt;&lt; &amp;(mytest2[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">testc_const_ref <span class="title">t4</span><span class="params">(mytest2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t4:"</span>&lt;&lt; &amp;(t4.inner[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;(mytest2[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的输出为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">org:0x7f39d2d5f010</span><br><span class="line">t1:0x7f39d2cfd010</span><br><span class="line">0x7f39d2d5f010</span><br><span class="line">t2:0x7f39d2d5f010</span><br><span class="line">0</span><br><span class="line">org:0x7f39d2c9b010</span><br><span class="line">t3:0x7f39d2c9b010</span><br><span class="line">0</span><br><span class="line">org:0x7f39d2c39010</span><br><span class="line">t4:0x7f39d1e45010</span><br><span class="line">0x7f39d2c39010</span><br></pre></td></tr></table></figure>
<p>==可以看出按值传参时需要在调用点和内部都用move才能避免内存分配。==<br>==按引用传参时，只需在子函数内move即可。==<br>==而以const 引用传参时，move不会生效，并且也不会有任何告警。==</p>
<p>3 如何使用string_view作为key来访问string为key的map<br>需要使用map&lt;string, int, less&lt;&gt;&gt;这样的方式建立map，否则find必须使用string做key。<br>当使用map&lt;string, int, less&lt;&gt;&gt; 建立map时，调用find实际上是把string_view透传到std:less这个模板中。<br>后续在find的过程中，less会把map中每一个待比较的string转为string_view，然后进行两个string_view的比较。<br>如果是调用find的时候，把string_view先转为string再传入，则find内部就不再需要构建临时object。<br>使用下面的示例进行对比测试，使用string_view的版本由于有string转string_view的过程，其速度要略微慢于string的版本。下面是g++-7 -O2编译的结果。性能差距在1%以内。<br> ./t3   string_view<br>102400<br>Time taken by function: 1254672 microseconds<br>./t4    string版本<br>102400<br>Time taken by function: 1243754 microseconds</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string_view key = <span class="string">"hello"</span>;   <span class="comment">//string key = "hello"</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>, less&lt;&gt;&gt; coll;  <span class="comment">//map&lt;string, int&gt; coll;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">102400</span>;i++)</span><br><span class="line">        coll.insert(make_pair(to_string(i),i));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; coll.<span class="built_in">size</span>()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">unsigned</span> rep = <span class="number">1024</span>*<span class="number">1024</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> re = coll.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">auto</span> start = high_resolution_clock::now(); </span><br><span class="line">    <span class="keyword">while</span> (rep--)</span><br><span class="line">    &#123;</span><br><span class="line">        re = coll.<span class="built_in">find</span>(key); <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">stop</span> = high_resolution_clock::now(); </span><br><span class="line">    <span class="keyword">auto</span> duration = duration_cast&lt;microseconds&gt;(<span class="built_in">stop</span> - start); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time taken by function: "</span></span><br><span class="line">        &lt;&lt; duration.count() &lt;&lt; <span class="string">" microseconds"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/02/llvm_tr7_mutable_variables/" data-id="cknykihma001votfadd2jbqba" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-elf_go" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/elf_go/" class="article-date">
  <time datetime="2020-03-02T03:12:42.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/elf_go/">ELFGO 编译和测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><pre><code>从https://github.com/pytorch/ELF 下载代码
在ELF的根目录下git submodule sync &amp;&amp; git submodule update --init --recursive获取第三方代码</code></pre><h2 id="使用docker方式进行构建"><a href="#使用docker方式进行构建" class="headerlink" title="使用docker方式进行构建"></a>使用docker方式进行构建</h2><pre><code>为减少对本地系统的冲击，可以使用docker 方式构建。
先进入ELF的根目录。
在编译前，需要对Dockerfile做一些小调整。
在原来的conda install后新增如下一行
RUN conda install pytorch torchvision cudatoolkit=10.0 -c pytorch
然后使用如下命令进行构建 (为了下载提速，挂了代理)
sudo docker build --network host  --build-arg HTTP_PROXY=socks5://127.0.0.1:1080 --build-arg HTTPS_PROXY=socks5://127.0.0.1:1080 -t elf_go:vtrunk .</code></pre><h1 id="运行时问题解决"><a href="#运行时问题解决" class="headerlink" title="运行时问题解决"></a>运行时问题解决</h1><h2 id="启动制作好的image，拷贝到host中，以便使用GPU"><a href="#启动制作好的image，拷贝到host中，以便使用GPU" class="headerlink" title="启动制作好的image，拷贝到host中，以便使用GPU"></a>启动制作好的image，拷贝到host中，以便使用GPU</h2><pre><code>sudo docker images 查看刚刚构建出的镜像id
启动如下的示例命令启动image，然后将我们需要的内容拷贝到host上</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker  run  -dit  --name elf_go  $&#123;your_image_id&#125;</span><br><span class="line">sudo docker cp elf_go:&#x2F;go-elf $&#123;your_host_elf_dir&#125;</span><br></pre></td></tr></table></figure>
<h2 id="准备host机的路径"><a href="#准备host机的路径" class="headerlink" title="准备host机的路径"></a>准备host机的路径</h2><pre><code>由于docker构建时使用了root用户，构建出的binary依赖了一些根路径下的目录。有很多办法可以解决这类问题。
治本的方案是修改编译体系，去除这些对根目录的依赖，将一个用户可控制目录作为根目录(或者使用相对路径)。但是修改的工作量比较大。
规避的办法也有一些，使用patchelf可以修改一些搜索路径，也可以考虑使用fakeroot等技术重定向文件访问的路径。修改的工作量还是略大。
这里用最粗暴的方法，用mount bind来建立一个满足访问要求的映射路径。
先行建立所需的路径。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;root&#x2F;miniconda3</span><br><span class="line">sudo mkdir &#x2F;go-elf</span><br></pre></td></tr></table></figure>
<pre><code>进入到我们拷贝路径${your_host_elf_dir}，使用如下命令完成映射</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o bind .&#x2F;miniconda3&#x2F; &#x2F;root&#x2F;miniconda3</span><br><span class="line">sudo mount -o bind .&#x2F;go-elf  &#x2F;go-elf</span><br></pre></td></tr></table></figure>
<p>最后设置搜索路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;root&#x2F;miniconda3&#x2F;bin</span><br></pre></td></tr></table></figure>
<h2 id="下载v2版本模型"><a href="#下载v2版本模型" class="headerlink" title="下载v2版本模型"></a>下载v2版本模型</h2><pre><code>主线elf版本只能使用v2版本的模型，Dockerfile中下载的v0版本无法使用。可从</code></pre><p><a href="https://dl.fbaipublicfiles.com/elfopengo/pretrained_models/pretrained-go-19x19-v2.bin" target="_blank" rel="noopener">https://dl.fbaipublicfiles.com/elfopengo/pretrained_models/pretrained-go-19x19-v2.bin</a> 下载后，放入${your_host_elf_dir}/go-elf/ELF中。</p>
<h2 id="适配python版本"><a href="#适配python版本" class="headerlink" title="适配python版本"></a>适配python版本</h2><pre><code>elf构建时docker内使用的python版本可能和host中的不一致。需要修改/go-elf/ELF/scripts/elfgames/go/gtp.sh中的启动命令，确保使用(dockerfile构建时)conda中安装的python版本。</code></pre><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">majiang@majiang-All-Series:~/hd/opensource/ELF_GO/builded_env/go-elf/ELF/scripts/elfgames/go$ git diff gtp.sh </span><br><span class="line">diff --git a/scripts/elfgames/go/gtp.sh b/scripts/elfgames/go/gtp.sh</span><br><span class="line">index 0ca7aba..3291ade 100755</span><br><span class="line"><span class="comment">--- a/scripts/elfgames/go/gtp.sh</span></span><br><span class="line"><span class="comment">+++ b/scripts/elfgames/go/gtp.sh</span></span><br><span class="line"><span class="meta">@@ -9,7 +9,7 @@</span></span><br><span class="line"> MODEL=$1</span><br><span class="line"> shift</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-game=elfgames.go.game model=df_pred model_file=elfgames.go.df_model3 python3 df_console.py --mode online --keys_in_reply V rv \</span></span><br><span class="line"><span class="addition">+game=elfgames.go.game model=df_pred model_file=elfgames.go.df_model3 python3.7 df_console.py --mode online --keys_in_reply V rv \</span></span><br><span class="line">     --use_mcts --mcts_verbose_time --mcts_use_prior --mcts_persistent_tree --load $MODEL \</span><br><span class="line">     --server_addr localhost --port 1234 \</span><br><span class="line">     --replace_prefix resnet.module,resnet init_conv.module,init_conv \</span><br></pre></td></tr></table></figure>
<pre><code>如果出现python版本不匹配问题，可能出现一些莫名其妙的模块找不到错误，如下所示。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#39;torch._C&#39;</span><br></pre></td></tr></table></figure>
<pre><code>其原因是，python的动态库对python版本有依赖，参考https://github.com/pytorch/pytorch/issues/574。host机器的python3如果不是conda所用的python3.7就会出现找不到库问题。</code></pre><h2 id="启动elf自带的脚本"><a href="#启动elf自带的脚本" class="headerlink" title="启动elf自带的脚本"></a>启动elf自带的脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;go-elf&#x2F;ELF&#x2F;scripts</span><br><span class="line">source devmode_set_pythonpath.sh</span><br><span class="line">cd &#x2F;go-elf&#x2F;ELF&#x2F;scripts&#x2F;elfgames&#x2F;go&#x2F;</span><br><span class="line">.&#x2F;gtp.sh ..&#x2F;..&#x2F;..&#x2F;pretrained-go-19x19-v2.bin --loglevel off --gpu 0 --num_block 20 --dim 256 --mcts_puct 1.50 --batchsize 256 --mcts_rollout_per_batch 16 --mcts_threads 2 --mcts_rollout_per_thread 8192 --resign_thres 0.05 --mcts_virtual_loss 1</span><br></pre></td></tr></table></figure>
<h2 id="解决代码问题"><a href="#解决代码问题" class="headerlink" title="解决代码问题"></a>解决代码问题</h2><h3 id="v-pin-memory-处的cuda-out-of-memory问题"><a href="#v-pin-memory-处的cuda-out-of-memory问题" class="headerlink" title="v.pin_memory()处的cuda out of memory问题"></a>v.pin_memory()处的cuda out of memory问题</h3><p>加了print (v)语句。go-elf/ELF/src_py/elf/utils_elf.py 44行<br>            print (v)<br>            if gpu is not None:<br>                with torch.cuda.device(gpu):<br>                    v = v.pin_memory()<br>            v.fill_(1)<br>似乎是偶发故障，后续没有再复现</p>
<h3 id="启动后使用genmove-B开始下棋，utils-elf-py-210出现了数据维度不匹配的问题"><a href="#启动后使用genmove-B开始下棋，utils-elf-py-210出现了数据维度不匹配的问题" class="headerlink" title="启动后使用genmove B开始下棋，utils_elf.py 210出现了数据维度不匹配的问题"></a>启动后使用genmove B开始下棋，utils_elf.py 210出现了数据维度不匹配的问题</h3><p>genmove B会有异常，经过检查可能是下面utils_elf.py 210出现了数据维度不匹配的问题，修改接口后解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#bk[:] &#x3D; v.squeeze_()</span><br><span class="line">bk[:] &#x3D; v.squeeze()</span><br></pre></td></tr></table></figure>
<p>错误现象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py(192)copy_from()</span><br><span class="line">-&gt; for k, v in this_src.items():</span><br><span class="line">(Pdb) y</span><br><span class="line">*** NameError: name &#39;y&#39; is not defined</span><br><span class="line">(Pdb) q</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;df_console.py&quot;, line 86, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;df_console.py&quot;, line 79, in main</span><br><span class="line">    GC.run()</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py&quot;, line 436, in run</span><br><span class="line">    self._call(smem, *args, **kwargs)</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py&quot;, line 404, in _call</span><br><span class="line">    keys_extra, keys_missing &#x3D; sel_reply.copy_from(reply)</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py&quot;, line 192, in copy_from</span><br><span class="line">    for k, v in this_src.items():</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py&quot;, line 192, in copy_from</span><br><span class="line">    for k, v in this_src.items():</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;miniconda3&#x2F;lib&#x2F;python3.7&#x2F;bdb.py&quot;, line 88, in trace_dispatch</span><br><span class="line">    return self.dispatch_line(frame)</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;miniconda3&#x2F;lib&#x2F;python3.7&#x2F;bdb.py&quot;, line 113, in dispatch_line</span><br><span class="line">    if self.quitting: raise BdbQuit</span><br></pre></td></tr></table></figure>
<h1 id="GTP协议问题"><a href="#GTP协议问题" class="headerlink" title="GTP协议问题"></a>GTP协议问题</h1><p>gtp脚本启动后可以在文本界面下使用GTP协议的指令下棋了。<br>但是sabaki围棋前端界面无法正常与eflgo进行GTP通信。<br>查看GTP协议，是ELFGO的额外打印干扰了协议解析。<br>参考<a href="https://github.com/pytorch/ELF/compare/master...Narsil:master，调整了console_lib.py" target="_blank" rel="noopener">https://github.com/pytorch/ELF/compare/master...Narsil:master，调整了console_lib.py</a> 中的</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    def print_msg(self, ret, msg):</span><br><span class="line"><span class="deletion">-        print("\n%s %s\n\n" % (("=" if ret else "?"), msg))</span></span><br><span class="line"><span class="addition">+        print("%s %s\n\n" % (("=" if ret else "?"), msg))</span></span><br></pre></td></tr></table></figure>
<p>启动gtp脚本时，可以添加–loglevel off选项关闭大量额外打印。</p>
<h1 id="封装脚本"><a href="#封装脚本" class="headerlink" title="封装脚本"></a>封装脚本</h1><p>为了sabaki等前端能比较方便的启动ELFGO后端，可以使用如下的封装脚本一次完成启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> -x</span></span><br><span class="line">cur_shell_dir="$( cd "$( dirname "$&#123;BASH_SOURCE[0]&#125;" )" &amp;&amp; pwd )"</span><br><span class="line">cd $&#123;cur_shell_dir&#125;</span><br><span class="line"></span><br><span class="line">cd ../../../../../</span><br><span class="line">sudo mount -o bind ./miniconda3/ /root/miniconda3</span><br><span class="line">sudo mount -o bind ./go-elf  /go-elf</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/root/miniconda3/bin</span><br><span class="line">cd ../../</span><br><span class="line">source devmode_set_pythonpath.sh</span><br><span class="line">cd -</span><br><span class="line">./gtp.sh ../../../pretrained-go-19x19-v2.bin --loglevel off --gpu 0 --num_block 20 --dim 256 --mcts_puct 1.50 --batchsize 256 --mcts_rollout_per_batch 16 --mcts_threads 2 --mcts_rollout_per_thread 8192 --resign_thres 0.05 --mcts_virtual_loss 1</span><br></pre></td></tr></table></figure>

<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>在sabaki中，当前elfgo还是只能 执黑。如果执白还是会卡死，可能协议文本的输出还有问题。<br>另外，说明中提到elfgo只能走贴7.5目的规则。</p>
<h1 id="另一个围棋AI，可以给出胜率估计的leela-zero"><a href="#另一个围棋AI，可以给出胜率估计的leela-zero" class="headerlink" title="另一个围棋AI，可以给出胜率估计的leela-zero"></a>另一个围棋AI，可以给出胜率估计的leela-zero</h1><p>下载并解压Lizzie.0.7.2.Mac-Linux.zip，然后进入解压后的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy&#x3D;&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">export https_proxy&#x3D;&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gcp&#x2F;leela-zero</span><br><span class="line">cd leela-zero</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">sudo apt install libboost-dev libboost-program-options-dev libopenblas-dev opencl-headers ocl-icd-libopencl1 ocl-icd-opencl-dev zlib1g-dev</span><br><span class="line">sudo apt install cmake g++ libboost-dev libboost-program-options-dev libboost-filesystem-dev opencl-headers ocl-icd-libopencl1 ocl-icd-opencl-dev zlib1g-dev</span><br><span class="line">mkdir build</span><br><span class="line">cmake ..&#x2F;</span><br><span class="line">...</span><br><span class="line">CMake Warning at CMakeLists.txt:129 (message):</span><br><span class="line">  Qt is not found, build for &#96;autogtp&#96; and &#96;validation&#96; is disabled</span><br><span class="line">...</span><br><span class="line">cmake --build .</span><br><span class="line">cd ..&#x2F;..&#x2F;</span><br><span class="line">cp .&#x2F;leela-zero&#x2F;build&#x2F;leelaz .&#x2F;</span><br><span class="line">chmod +x  .&#x2F;lizzie.jar</span><br><span class="line">.&#x2F;lizzie.jar</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/02/elf_go/" data-id="cknykihlx001hotfabyyrc3dm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo升级和添加图片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/hexo%E5%8D%87%E7%BA%A7%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/" class="article-date">
  <time datetime="2020-03-02T03:12:42.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/hexo%E5%8D%87%E7%BA%A7%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/">hexo升级和插入图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="插入图片失败"><a href="#插入图片失败" class="headerlink" title="插入图片失败"></a>插入图片失败</h1><p>参考<a href="https://blog.csdn.net/u010996565/article/details/89196612" target="_blank" rel="noopener">https://blog.csdn.net/u010996565/article/details/89196612</a> 等文章的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>然后在文本中插入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;图片名&quot;  width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot;&gt;</span><br><span class="line">![](image图片名)</span><br></pre></td></tr></table></figure>
<p>均无法正确显示图片。<br>hexo sever启动的终端可以看到如下提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update link as:--&gt;&#x2F;.com&#x2F;&#x2F;xxxx.png</span><br></pre></td></tr></table></figure>
<p>打开图片的地址也是/.com//xxxx.png。<br>搜索到如下的网页介绍了类似的问题。<br><a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br>但是其提供的方案也无法生效。<br>考虑到安装 hexo-asset-image时曾经提到需要hexo4.0以上版本，而当前hexo版本是3.9，所以考虑先行升级版本</p>
<h1 id="升级hexo"><a href="#升级hexo" class="headerlink" title="升级hexo"></a>升级hexo</h1><p>参考如下链接<br><a href="https://www.dazhuanlan.com/2020/01/29/5e3165c116e0f/?__cf_chl_jschl_tk__=e7caf23cde91dcc1f9fc6e1006b88d0bf63de758-1584498843-0-AQ7fucDfahofVnETCllMEC0jJ8Wrecp_5-NxLutNm_NE07_6SkOP9aYE2mlgJv6oQ9Z78RVSuvf1uZBXN-AwXQ898WXTdcE5uf90w-_XCgWONaii4YIUO62_6vLfMSqvz4miZBzOpMYwmaop6pjkWnQWyhJIsJ-LkHyQXZPBRAteDLBEWZ1-gkaq3aXBT4DZl6-I2wJ_R1WFiBqHDlBlrr2treoeNxPspJpjB0L5Qzd1-8JtGPUprKEBt2KCKCjAXtWL9NZ6TJb93L6wrwpWsJdY45QkNxfwTYq6NPOPd4H3suwbWr1P_FY2lWzbk7NfwQ" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/01/29/5e3165c116e0f/?__cf_chl_jschl_tk__=e7caf23cde91dcc1f9fc6e1006b88d0bf63de758-1584498843-0-AQ7fucDfahofVnETCllMEC0jJ8Wrecp_5-NxLutNm_NE07_6SkOP9aYE2mlgJv6oQ9Z78RVSuvf1uZBXN-AwXQ898WXTdcE5uf90w-_XCgWONaii4YIUO62_6vLfMSqvz4miZBzOpMYwmaop6pjkWnQWyhJIsJ-LkHyQXZPBRAteDLBEWZ1-gkaq3aXBT4DZl6-I2wJ_R1WFiBqHDlBlrr2treoeNxPspJpjB0L5Qzd1-8JtGPUprKEBt2KCKCjAXtWL9NZ6TJb93L6wrwpWsJdY45QkNxfwTYq6NPOPd4H3suwbWr1P_FY2lWzbk7NfwQ</a><br>使用如下步骤，将hexo升级到了4.2.0<br>1 清除node的cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure>
<p>2 安装node版本管理工具 n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure>
<p>3 安装最新稳定版本的node</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n stable</span><br></pre></td></tr></table></figure>
<p>// 安装最新版本使用 n latest<br>// 安装指定版本的使用 n {version}，例如 n 11.2.0<br>// 删除指定版本的node使用 n rm {version}，例如 n rm 11.2.0<br>4 更新npm版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm@latest -g</span><br></pre></td></tr></table></figure>
<p>5 进入blog目录，然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure>
<p>6  根据第5步输出，手工记录各个组件的最新版本号，然后逐一在package.json配置文件中修改版本号到最新版本。</p>
<p>7 更新模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save</span><br></pre></td></tr></table></figure>
<p>8 确认升级结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<h1 id="升级后的问题解决"><a href="#升级后的问题解决" class="headerlink" title="升级后的问题解决"></a>升级后的问题解决</h1><p>升级后图片仍然无法正常显示。<br>异常现象变为，路径正常时，网页上就直接显示路径文本，而不是显示图片。<br>而使用部分博客提到的语法，则生成的网页中直接就是空白（查看html文件，整段内容直接被忽略了）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img slug [title] %&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到部分博客提到hexo4.0把很多插件并入了核心代码，担心插件中有冲突，于是使用下面的命令卸载掉第三方插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-asset-link --save</span><br><span class="line">npm remove hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>然后再在文件中使用markdown的语法，就能正确显示图片了。<br>并且主页中的图片也能正常显示，应该是hexo4.0把image link并入核心代码后做了改进（pacakge.json中显示多了一个hexo-image-link组件），解决了markdown语法的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt Text](图片文件 &quot;Title Text&quot;)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/02/hexo%E5%8D%87%E7%BA%A7%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/" data-id="cknykihl2000gotfacuhb6s4n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr6_user_defined_operator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/21/llvm_tr6_user_defined_operator/" class="article-date">
  <time datetime="2020-02-21T10:22:51.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/llvm_tr6_user_defined_operator/">Kaleidoscope user defined operator</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 命名时没有限制operator是否能是常规字符(如abc,123等)，会否产生静默的关键字冲突？<br>2 考虑如何处理两个特殊字符组成的操作符，如==　!=等。<br>3 示例中的自定义operator是否能作为库使用？如果不能应该如何改进？</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>完成了原示例自定义binary和unary operator的功能，但是未支持用户定义”unary-“。<br>尚未支持unary-的原因是为了阻止用户犯错，我们禁止了用户定义使用保护字符（包括内置运算符、分隔符等）的operator。这里的检查规则比较简单，仅仅实现了基于char的比较，实际上过于严格，以至于阻止了用户定义unary-这样的合法要求。后续细化保护规则后(拆分运算符和受保护的字符两种类型，对运算符区分binary和uary类型)，即可支持unary-。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现过程中发现原示例确实精炼，仅用很少的代码便实现了用户自定义operator的功能。但是，其精炼的代价是该功能仅仅具有演示价值而几乎没有实用价值。<br>例如，原示例没有在lexer做token分层，parser会直接读取输入的char。这样一来lexer可以非常非常简单。并且，在新增语法功能时，parser由于可以直接穿透处理char，需要新增的配合代码也很少。<br>但是这样的设计导致代码维护困难，parser中要直接处理token拆分逻辑，一旦语法变复杂，新增功能或更改已有逻辑(直接操作char的地方会很多)就会很困难。<br>另外，原示例没有错误防护的逻辑，这会导致用户犯错很难定位原因。</p>
<p>实现过程中针对前面扩展中提出的问题，一一进行了改进。详细情况可参考扩展问题一节中的描述。<br>从实现后的实际情况看，改进引入了相当多的额外代码，工作量较大。作为示例，相较于引入大量的细节流程，原作者使用精简的方案确实是更好的权衡（示例丧失了扩展为真正可实用编译器的潜力，但仍然展现了主要的原理，解决了核心问题）。</p>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 命名时没有限制operator是否能是常规字符(如abc,123等)，会否产生静默的关键字冲突？<br>原示例几乎没有对自定义operator做错误防护。这将导致用户错误定义operator，很难察觉和定位到根因。<br>如下所示，覆盖内置操作符的优先级和语义将导致二义性和混乱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def binary + 80 (a b) a+b; </span><br><span class="line">ready&gt; Read function definition:define double @&quot;binary+&quot;(double %a, double %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp &#x3D; fadd double %a, %b</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; 1+2*3;</span><br><span class="line">ready&gt; Evaluated to 9.000000</span><br></pre></td></tr></table></figure>

<p>定义保留字符’,’，parser无法理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def unary , (a) a+1;</span><br><span class="line">ready&gt; Read function definition:define double @&quot;unary,&quot;(double %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp &#x3D; fadd double %a, 1.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line">ready&gt; def xy3(a) a+,a;</span><br><span class="line">ready&gt; Error: unknown token when expecting an expression</span><br><span class="line">ready&gt; Error: Unknown variable name</span><br></pre></td></tr></table></figure>

<p>定义保留字符’(‘，parser无法理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def unary ( (a) a+1;</span><br><span class="line">ready&gt; Read function definition:define double @&quot;unary(&quot;(double %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp &#x3D; fadd double %a, 1.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line">ready&gt; def xy4(a) a+(1  </span><br><span class="line">ready&gt; ;</span><br><span class="line">Error: expected &#39;)&#39;</span><br></pre></td></tr></table></figure>
<p>为了避免这些错误，在实现时专门针对binary/unary的名称做了正确性校验(verify_operator_sym函数)。<br>在错误第一现场阻止错误，并给出清晰的提示。</p>
<p>2 考虑如何处理两个特殊字符组成的操作符，如==　!=等。<br>原示例由于使用了char来作为operator的opcode，实际上就无法支持两字符操作符。但使用单char作为operator的opcode，大大简化了构建operator token的难度。因为只需要在parser中按需读出一个char就可以，无需考虑在lexer中如何正确切分的问题。<br>为了支持!= 和==等显然有意义的两字符operator，本次实现时在lexer中添加了一个map查找机制，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur_token == TOKEN_BINARY || cur_token == TOKEN_UNARY)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (install_user_defined_operator(input_stream, cur_char))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get_user_defined_operator(input_stream, cur_char))</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>install_user_defined_operator函数，在binary和unary关键字后识别并注册(就是插入到map中)用户自定义的operator token。<br>get_user_defined_operator中就可以查找已经注册的用户自定义operator，并给出正确的token类型（用户自定义unary或者binary）。</p>
<p>3 示例中的自定义operator是否能作为库使用？如果不能应该如何改进？<br>从实现原理上来说，因为operator 也是在proto中解析的，与函数一样。<br>所以自定义的operator只要遵循先extern申明，再引用的规则，就可以以库的方式正常使用(定义在单独的库文件中，使用时链接二进制文件)。<br>但是，原示例没有考虑容错问题。<br>parser在工作时是按照extern声明的优先级工作。如果定义时的优先级和extern时的不一致，则程序的逻辑将静默改变。用户要发现这样的问题可能很困难（这个和C中没有正确包含头文件的情况类似）。<br>为了解决这个问题，参考C++的方法，把prio作为一个强制信息加入到binary/unary函数的名称中。这样一旦extern声明和def的定义不一致，链接时会找不到函数定义。用户将不能得到可工作（但逻辑错误）的二进制文件。</p>
<h3 id="实现中遇到的问题"><a href="#实现中遇到的问题" class="headerlink" title="实现中遇到的问题"></a>实现中遇到的问题</h3><p>1 prototype_tab的key从string切换到string_view后，遇到了内存数据错误的问题。详细记录如下。<br>使用string_view作为map的key时，我们调用了tab.insert(make_pair(a_string, my_val));。原以为string会自动转为string_view，tab中的key(string_view)数据应该指向a_string。实际发现key的数据指向了一个insert所在的函数栈。<br>使用下面的小型测试用例即可复现出问题，pair中的key并不是指向我们希望的全局数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_view</span><span class="params">(pair&lt;string_view, <span class="keyword">int</span>&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"value:"</span>&lt;&lt; p.first.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"address:"</span> &lt;&lt; (<span class="keyword">void</span>*)p.first.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">global</span><span class="params">(<span class="string">"abc"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"value_global:"</span> &lt;&lt; global.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"address_global:"</span> &lt;&lt; (<span class="keyword">void</span>*)global.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        test_view(make_pair(global,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用g++ save-temps -fdump-tree-all-details -std=c++17编译上面的代码，可以比较清楚地看出问题。<br>这里的核心错误在于：<br>make_pair是一个模板函数，(为了提供泛型能力)它并不知道（或者提供这个约束）第一个参数应该是string_view。当我们提供一个string作为第一个参数时，test_view(make_pair(global,1));的调用并没有变成我们希望的test_view(make_pair((string_view)global,1))。而是变成了如下的序列。<br>tmp_pair = make_pair&lt;string, int&gt;(global, 1);<br>tmp_pair_to_call = pair&lt;string_view, int&gt; (tmp_pair);<br>test_view(tmp_pair_to_call);<br>这样传到test_view中pair中的string_view实际上指向栈上创建的临时变量。一旦tmp_pair所在的函数return，string_view中的key就乱掉了（use after free）。</p>
<p>从这次经历看string_view确实是非常容易出错的点，使用时需要特别谨慎。参考 <a href="https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/" target="_blank" rel="noopener">https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/</a> 的如下示例，string_view允许指向临时对象，这确实很容易导致错误，并且很难发现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"Hellooooooooooooooo "</span>;</span><br><span class="line">  <span class="built_in">std</span>::string_view sv = s + <span class="string">"World\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 切换到clang8编译器后，优化LLVM-IR时程序段错误。<br>google搜索到了下面的邮件，这是一个gcc/clang的abi兼容性问题。<br><a href="http://lists.llvm.org/pipermail/llvm-dev/2019-January/129567.html" target="_blank" rel="noopener">http://lists.llvm.org/pipermail/llvm-dev/2019-January/129567.html</a><br>需要将llvm库用clang重新编译（或者升级到最新的llvm）。<br>升级到最新的llvm代码后确实解决了该问题。</p>
<p>3 升级到最新的llvm后，遇到了asan报大量indirect leak问题。<br>仔细检查代码后，发现llvm_optimizer::optimize_function等函数中，<br>使用了createTargetMachine创建的TargetMachine *。<br>添加了delete TargetMachine *的语句后，leak告警消失。<br>老版本为何没报leak，暂时没有进一步核查。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/02/21/llvm_tr6_user_defined_operator/" data-id="cknykihlz001kotfa94tx7mkq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr5_control_flow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/18/llvm_tr5_control_flow/" class="article-date">
  <time datetime="2020-02-18T15:12:20.000Z" itemprop="datePublished">2020-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/18/llvm_tr5_control_flow/">Kaleidoscope control flow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>原示例中for引入了循环变量，但是仍然没有引入scope之类的概念，而是直接将所有变量名称放到function的NamedValues map(我们的实现是cur_func_args)中。这个是否会产生命名冲突，是否一定需要建立分级的命名查找表？</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>完成了原示例的if和for添加。<br>实现过程中发现原示例的for逻辑有问题，参考if的写法做了重写。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>大部分语言使用’,’ 作为顺序求值的符号，后续Kaleidoscope也会增加多语句的支持。因此实现时将原示例中的for表达式中的分隔符从”,” 改为了”:”，将”,”预留出来。</p>
<p>实现时的主要变更是改写了for的语义，具体情况如下：<br>原示例中的for循环展开时，是先执行完成loop后再做结束检查，这和通常语言的for定义都冲突。<br>使用原示例的代码，如下循环仍然会打印出数字1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def forWrong()</span><br><span class="line">    for x &#x3D; 1: x &lt; 1: 1 in</span><br><span class="line">        print(x)</span><br></pre></td></tr></table></figure>
<p>这很明显不是多数人理解的for语义。</p>
<p>实现for的IR生成代码时，重写了其逻辑，修改后的逻辑框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">preheader_bb:</span><br><span class="line">	计算induction var(指示变量)的初始值</span><br><span class="line">	goto to end_check</span><br><span class="line">end_check:</span><br><span class="line">	计算end expr的值end_val是否为true</span><br><span class="line">	if (end_val)</span><br><span class="line">		goto loop</span><br><span class="line">	else</span><br><span class="line">		goto afterloop</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	计算循环体body expr的值</span><br><span class="line">	induction var +&#x3D; step</span><br><span class="line">	goto end_check</span><br><span class="line"></span><br><span class="line">after_loop:</span><br><span class="line">	xxxx后续指令</span><br></pre></td></tr></table></figure>
<p>修改后的for工作逻辑与c等语言保持了一致。</p>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>在展开for表达式时，原示例代码先保存了for指示变量可能会覆盖的变量名，离开for展开流程时，再恢复原始值（如果没有重名，那就把for定义的指示变量从名称查找map named_var中移除）。这样看来，遵循底层覆盖上层的原则，并且不提供访问上层被覆盖值的机制，那么确实无需专门定义scope的概念。<br>如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def xt(i)</span><br><span class="line">    for i &#x3D; 0 : i &lt; 5 : 1 in</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>
<p>即使在for表达式后，还可以添加其他语句。那么其他语句也可以正常访问到入参i的值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/02/18/llvm_tr5_control_flow/" data-id="cknykihl8000rotfaf83l80mw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr4_optimizer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/14/llvm_tr4_optimizer/" class="article-date">
  <time datetime="2020-02-14T09:33:23.000Z" itemprop="datePublished">2020-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/14/llvm_tr4_optimizer/">Kaleidoscope optmizer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能（但将原示例的JIT方式改为传统编译流程）。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 在dump出LLVMIR后，能否使用编译好的llvm组件实现编译运行等功能？应该如何做？<br>2 编写一个driver封装(可以使用shell)，把main函数作为入口编译成可执行程序</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>完成了原示例中的优化部分，删掉了原示例中的JIT部分。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现了如下的主要变更：<br>1 删掉了JIT功能，原实例中的扩展库函数没有实际意义也删掉了（有extern语法就肯定能扩展，与JIT功能无关）<br>2 新增了模块级别的优化功能，可以对单个源代码文件进行整体优化（如inline等）<br>3 将Passmanager的实现从示例的legacy切换到了新的实现上<br>4 实现了输入文件的编译</p>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 玩具前端codegen到出LLVM-IR后，可以使用LLVM提供的独立opt工具进行优化，优化后的输出可以是LLVM-IR的文本形式(-S参数)也是可以bitcode。然后再使用clang编译成二进制文件，就可以进行通常的链接了。也就是说，如果不介意多一次IR导出和IR导入的性能损耗，其实优化是完全可以不必在toy_compiler中实现的。</p>
<p>2 编写了一个compiler.sh，可以把入参文件编译为可执行文件（需要提供main函数）。添加了一个kout函数专门用于打印函数返回值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/02/14/llvm_tr4_optimizer/" data-id="cknykihl3000iotfadsevg28s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; __(&#39;prev&#39;)</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__(&#39;next&#39;) &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANDROID/" rel="tag">ANDROID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GRAALVM/" rel="tag">GRAALVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/" rel="tag">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/env/" rel="tag">env</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 20px;">AI</a> <a href="/tags/ANDROID/" style="font-size: 16.67px;">ANDROID</a> <a href="/tags/Android/" style="font-size: 13.33px;">Android</a> <a href="/tags/GRAALVM/" style="font-size: 16.67px;">GRAALVM</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/LLVM-STUDY/" style="font-size: 20px;">LLVM_STUDY</a> <a href="/tags/env/" style="font-size: 10px;">env</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/17/react_native_profile/">react native 手势动画性能分析</a>
          </li>
        
          <li>
            <a href="/2021/05/28/android_rust_dev/">Android Rust 接入</a>
          </li>
        
          <li>
            <a href="/2021/04/27/node_js_native_plugin_ana/">nodejs native 插件调研</a>
          </li>
        
          <li>
            <a href="/2021/03/26/graalvm_observing_compilations/">graalvm 编译过程分析工具</a>
          </li>
        
          <li>
            <a href="/2021/03/10/android_startup_trace/">app_process 初始化阶段trace</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Ma Jiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>