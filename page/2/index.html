<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>mjblog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="mjblog">
<meta property="og:url" content="http://mjblog.github.io/page/2/index.html">
<meta property="og:site_name" content="mjblog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ma Jiang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="mjblog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">mjblog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mjblog.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-TVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/20/TVM/" class="article-date">
  <time datetime="2020-03-20T02:07:29.000Z" itemprop="datePublished">2020-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/20/TVM/">TVM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TVM是一套端到端的深度学习编译系统。<br>它的主要特性如下图所示。</p>
<img src="/2020/03/20/TVM/tvm-stack.png" class="" title="TVM 示意图">
<p>第一，它支持将多种前端模型( Keras, MXNet, PyTorch, Tensorflow, CoreML, DarkNet等)编译到多种后端硬件上(包括传统的CPU/GPU，还包括FPGA、TPU等专用加速硬件)。<br>第二，它提供了一整套自动优化基础设施，能够帮助用户快速在一个新的硬件体系下建立起较高的性能。</p>
<h1 id="独到之处"><a href="#独到之处" class="headerlink" title="独到之处"></a>独到之处</h1><p>TVM 相对它的前辈如(Halide)，有两个创新的点值得关注。</p>
<img src="/2020/03/20/TVM/tvm_detail.png" class="" title="TVM 处理过程">
<p>其一：<br>section4部分引入了一个可扩展的tensor compute primitives  (就是硬件支持的用于特定矩阵运算的原语)描述方法。这使得TVM能快速支持新的硬件加速指令。<br>如下图所示。</p>
<img src="/2020/03/20/TVM/extensive_tensorization.png" class="" title="TVM 可扩展的张量化">
<p>使用类似RISC的思路，只需要提供少量细粒度的基本步骤，就可以通过组合配置建模出复杂的硬件加速指令。</p>
<p>其二：<br>TVM提供的autotuner相当强大。</p>
<img src="/2020/03/20/TVM/tvm_autotune.png" class="" title="TVM 自动调优系统">

<p>TVM支持常规的黑盒自动优化，也就是使用黑盒优化算法反复到硬件上运行程序获得性能。<br>也支持基于预测的自动优化，在这种模式下，TVM根据硬件上获得的性能测试结果，训练出了一个性能预测模型。使用这个预测模型，TVM能实现快速的调优空间探索(论文中的效果比黑盒算法好)。因为模型预测很快，耗时低于1ms，而真实运行测试可能需要多耗费几十倍的时间。并且模型能持续从硬件中学习，而黑盒优化算法每次都必须从头开始。</p>
<h1 id="TVM和其他项目的关系"><a href="#TVM和其他项目的关系" class="headerlink" title="TVM和其他项目的关系"></a>TVM和其他项目的关系</h1><p><a href="https://github.com/apache/incubator-tvm/blob/master/docs/faq.rst" target="_blank" rel="noopener">https://github.com/apache/incubator-tvm/blob/master/docs/faq.rst</a></p>
<h2 id="和Halide关系"><a href="#和Halide关系" class="headerlink" title="和Halide关系"></a>和Halide关系</h2><p><a href="https://github.com/apache/incubator-tvm/issues/682" target="_blank" rel="noopener">https://github.com/apache/incubator-tvm/issues/682</a><br><a href="http://docs.tvmlang.org/faq.html#tvm-s-relation-to-other-ir-dsl-projects" target="_blank" rel="noopener">http://docs.tvmlang.org/faq.html#tvm-s-relation-to-other-ir-dsl-projects</a> answers the difference from existing projects, including Halide. In short, we specifically focus on deep learning, and optimize for multiple hardware backends (GPUs and other accelerators).</p>
<p>The major challenge is to make the schedule space complete enough to cover the state of art kernels for hardware back-ends we want to support, specifically gpu and other hardwares. The second challenge is to build the dsl representation to cover things we care about in deep learning(e.g. recurrence). The other issues include the ease of deployment and interpolation.</p>
<p>These challenges are not well addressed by existing frameworks(including Halide) and requires rethink and design of the stack as opposed to simply reuse an existing one.</p>
<p>You can also find that the TVM’s IR itself is evolving, and we continuously learn new lessons from hand optimization and tuning for various backends.</p>
<h2 id="和MLIR的关系"><a href="#和MLIR的关系" class="headerlink" title="和MLIR的关系"></a>和MLIR的关系</h2><p>参考<a href="https://discuss.tvm.ai/t/google-lasted-work-mlir-primer/1721/15" target="_blank" rel="noopener">https://discuss.tvm.ai/t/google-lasted-work-mlir-primer/1721/15</a><br>中TVM作者的如下回复。</p>
<p>Interpretation of MLIR’s Vision</p>
<p>I think what you answered reflects MLIR’s vision. Make the abstract class of IR and derive dialects. But not necessarily provide specific pass for the dialect, so if X-IR is a dialect of MLIR, then there are dialect specific passes that is needed in the pass.</p>
<p>Polyhedral dialect is a dialect in MLIR. In the current case, the polyhedral IR is part of the mlir codebase, which gives the view of “native”, but non-the-less it is a dialect just like the other automatic optimization dialect. The fact that it is part of the native code base does give an opinionated view of what what automatic optimization should be like in MLIR ecosystem. I think it is still very much an open problem, TVM has done a lot in this direction, and we can collectively innovate on this area.<br>How TVM can work with MLIR</p>
<p>First of all, MLIR won’t make TVM obsolete. In the contrary, it can help TVM stack by providing insights in IR design and possibly some lowering infrastructure.The community will keep improving our current IR infrastructure toward a better unified TVM-IR infra. We will try to define TVM dialects in MLIR to see if it makes sense to allow bi-directional translation between MLIR and TVM-IR, this way we can take benefit of some of the infra provided by MLIR and make TVM work together with MLIR’s ecosystem.</p>
<h1 id="一些初步的认知"><a href="#一些初步的认知" class="headerlink" title="一些初步的认知"></a>一些初步的认知</h1><p>从已有的信息看，针对新的硬件体系或者新的运算逻辑，TVM应该是一个不错的选择。<br>初步查看的结果，其文档比较丰富，如果使用python接口编程，易用性也不错。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="使用O0-g构建"><a href="#使用O0-g构建" class="headerlink" title="使用O0 -g构建"></a>使用O0 -g构建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..&#x2F; -DCMAKE_BUILD_TYPE&#x3D;Debug</span><br></pre></td></tr></table></figure>
<h2 id="获取各个op的运行时间"><a href="#获取各个op的运行时间" class="headerlink" title="获取各个op的运行时间"></a>获取各个op的运行时间</h2><p>只需使用debug_runtime替代普通runtime即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tvm.contrib.debugger <span class="keyword">import</span> debug_runtime <span class="keyword">as</span> graph_runtime</span><br></pre></td></tr></table></figure>
<p>具体实现可参考src/runtime/graph/debug/graph_runtime_debug.cc中的RunIndividual函数。其实核心就是对每一个op运行计时。<br>输出的有价值信息主要包括两类：<br>a 是在后台输出按执行顺序排列的op运行时间(如果是notebook，这个信息不会出现在浏览器中，会出现在启动notebook的终端)<br>b 是在notebook中打印按耗时占比排序的op执行时间</p>
<h2 id="获取各个pass执行后的IR"><a href="#获取各个pass执行后的IR" class="headerlink" title="获取各个pass执行后的IR"></a>获取各个pass执行后的IR</h2><h2 id="使用git-bisect定位问题"><a href="#使用git-bisect定位问题" class="headerlink" title="使用git bisect定位问题"></a>使用git bisect定位问题</h2><p>在tvm的目录下：<br>使用git bisect start开始二分查找<br>然后使用git bisect good $commit_id和git bisect bad ${commit_id}指定搜索区间。<br>就可以反复使用 cd build;cmake ../ -DCMAKE_BUILD_TYPE=Debug ; make -j 6构建并运行tvm，观察行为是否正常。<br>如果正常就git bisect good，如果异常就git bisect bad；如果中途某个版本遇到其他问题(例如还有其他bug干扰)，可以使用git bisect skip。<br>找到问题后，使用git bisect reset还原。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/20/TVM/" data-id="ckg246lpc000052faduy16qf6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HALIDE" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/17/HALIDE/" class="article-date">
  <time datetime="2020-03-17T09:41:32.000Z" itemprop="datePublished">2020-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/17/HALIDE/">HALIDE</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>参考 <a href="https://halide-lang.org/" target="_blank" rel="noopener">https://halide-lang.org/</a> 和 <a href="http://stellar.mit.edu/S/course/6/sp15/6.815/courseMaterial/topics/topic2/lectureNotes/14_Halide_print/14_Halide_print.pdf。" target="_blank" rel="noopener">http://stellar.mit.edu/S/course/6/sp15/6.815/courseMaterial/topics/topic2/lectureNotes/14_Halide_print/14_Halide_print.pdf。</a><br>Halide 的核心思想是把图像处理(可以理解为矩阵运算)的算法(需要计算什么内容)和调度(如何优化执行计算)分开。</p>
<h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>大规模的矩阵运算性能优化空间很大，但是目前已有的人工优化和编译器优化都有一些问题。<br>人工优化，有两种范式，一种是针对具体的场景手工优化，一种是提供BLAS, IPP, MKL, OpenCV这类高度优化的库。前一种效率太低(场景众多，还要针对不同的后端硬件，优化工作量太大)，后者则只能提供局部最优的模块，无法在全局进行调度和融化优化。<br>编译器优化，可以看见完整的运算pipeline，但是优化的效果相对手动优化差了很多(就是一个最简单的矩阵乘法，编译器的输出都可能比手工优化要慢数倍)。同时，编译器中的很多核心优化决策都没有开放外部控制（比较典型的是，连循环展开的次数，GCC等编译器都是最近几年才通过#pragma unroll等方式提供了支持，更不要说直接控制cache block的大小等等），这导致在编译器的基础上人工再调优(纠正编译器的错误优化决策)很困难。<br>综合以上信息，高效和高质量的全局优化，还是要靠编译器。Halide的创造者也是沿着这个思路解决问题。</p>
<h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h2><p>Halide 是一种DSL(领域语言)，也是该DSL的编译器。<br>它的核心思想是把运算的逻辑和运算的过程分离。将运算过程剥离出后，再将各个典型优化决策的控制变量和控制逻辑暴露出来，以便人工或者黑盒优化算法(如遗传算法等)能持续调整优化决策，达到更好的性能。<br>它主页中的示例代码很好的说明了其思想，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Func <span class="title">blur_3x3</span><span class="params">(Func input)</span> </span>&#123;</span><br><span class="line">  Func blur_x, blur_y;</span><br><span class="line">  Var x, y, xi, yi;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The algorithm - no storage or order</span></span><br><span class="line">  blur_x(x, y) = (input(x<span class="number">-1</span>, y) + input(x, y) + input(x+<span class="number">1</span>, y))/<span class="number">3</span>;</span><br><span class="line">  blur_y(x, y) = (blur_x(x, y<span class="number">-1</span>) + blur_x(x, y) + blur_x(x, y+<span class="number">1</span>))/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The schedule - defines order, locality; implies storage</span></span><br><span class="line">  blur_y.tile(x, y, xi, yi, <span class="number">256</span>, <span class="number">32</span>)</span><br><span class="line">        .vectorize(xi, <span class="number">8</span>).parallel(y);</span><br><span class="line">  blur_x.compute_at(blur_y, x).vectorize(x, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> blur_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将blur的运算逻辑，与具体运算的实施过程进行了分离。用很简单的几个方法就指定了tile/vectorize等重要优化，以及其对应的参数。直观看起来，代码很简洁，并且要修改优化的类型和参数，工作量也很小。<br>而要迫使编译器实现同样的优化，需要写下面一大段代码。<br>并且，这样的代码由于直接使用intel 的SIMD原语，可移植性大幅度下降。<br>更加严重的是，想要微调各项优化参数(为了针对不同的硬件做优化)，都需要对代码做大幅度的修改，工作量很大。<br>而上面的Halide代码，只需修改几个入参就可以完成优化决策的调整。哪怕Halide不提供内置的autotuner，使用一个简单的python脚本接入opentuner等黑盒优化框架也都会非常简单（毕竟只是改几个参数而已）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">box_filter_3x3</span><span class="params">(<span class="keyword">const</span> Image &amp;in, Image &amp;blury)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __m128i one_third = _mm_set1_epi16(<span class="number">21846</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> yTile = <span class="number">0</span>; yTile &lt; in.<span class="built_in">height</span>(); yTile += <span class="number">32</span>) &#123;</span><br><span class="line">        __m128i a, b, c, sum, avg;</span><br><span class="line">        __m128iblurx[(<span class="number">256</span>/<span class="number">8</span>)*(<span class="number">32</span>+<span class="number">2</span>)]; <span class="comment">// allocate tile blurx array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> xTile = <span class="number">0</span>; xTile &lt; in.<span class="built_in">width</span>(); xTile += <span class="number">256</span>)&#123;</span><br><span class="line">            __m128i *blurxPtr = blurx;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">-1</span>; y &lt; <span class="number">32</span>+<span class="number">1</span>; y++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">uint16_t</span> *inPtr = &amp;(in[yTile+y][xTile]);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">256</span>; x += <span class="number">8</span>)&#123;</span><br><span class="line">                             a = _mm_loadu_si128((__m128i*)(inPtr<span class="number">-1</span>));</span><br><span class="line">                             b = _mm_loadu_si128((__m128i*)(inPtr+<span class="number">1</span>));</span><br><span class="line">                             c = _mm_load_si128((__m128i*)(inPtr));</span><br><span class="line">                             sum = _mm_add_epi16(_mm_add_epi16(a, b), c);</span><br><span class="line">                             avg = _mm_mulhi_epi16(sum, one_third);</span><br><span class="line">                             _mm_store_si128(blurxPtr++, avg);</span><br><span class="line">                             inPtr += <span class="number">8</span>;</span><br><span class="line">                             &#125;&#125;</span><br><span class="line">                             blurxPtr = blurx;</span><br><span class="line">                             <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">32</span>; y++) &#123;</span><br><span class="line">                                 __m128i *outPtr = (__m128i *)(&amp;(blury[yTile+y][xTile]));</span><br><span class="line">                                 <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">256</span>; x += <span class="number">8</span>) &#123;</span><br><span class="line">                                            a = _mm_load_si128(blurxPtr+(<span class="number">2</span>*<span class="number">256</span>)/<span class="number">8</span>);</span><br><span class="line">                                            b = _mm_load_si128(blurxPtr+<span class="number">256</span>/<span class="number">8</span>);</span><br><span class="line">                                            c = _mm_load_si128(blurxPtr++);</span><br><span class="line">                                            sum = _mm_add_epi16(_mm_add_epi16(a, b), c);</span><br><span class="line">                                            avg = _mm_mulhi_epi16(sum, one_third);</span><br><span class="line">                                            _mm_store_si128(outPtr++, avg);</span><br><span class="line">                                            &#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><p>Halide介绍ppt中的一页示意图很好地展示了它的工作过程。</p>
<img src="/2020/03/17/HALIDE/halide_work.png" class="" title="Halide 示意图">
<p>图中飘逸的寥寥几笔注释已经把核心的工作原理讲清楚了。<br>如果对编译技术比较熟悉，看完注释后最核心的几个疑问应该就豁然开朗了。<br>简单的说，Halide语言没有独立的语法定义，也就不需要独立的lexer和parser。<br>它利用了C++语言的元编程能力，直接构造出了Halide语言的中间表达IR。<br>具体情况，随后一节会有详细的分析。</p>
<h1 id="语言实现分析"><a href="#语言实现分析" class="headerlink" title="语言实现分析"></a>语言实现分析</h1><p>为了分析Halide编译器的具体实现，下载并编译了Halide的代码(使用Ubuntu18.04自带的clang/llvm8，按照官方命令编译，比较简单)。<br>然后编译、运行和调试其tutorial目录中的各个示例。<br>可以对其实现有一个大致的了解。</p>
<h2 id="语言定义"><a href="#语言定义" class="headerlink" title="语言定义"></a>语言定义</h2><p>从最简单的示例入手，理解整体概念更容易。<br>参考下面代码注释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个示例用Halide完成了一个矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*这里声明了三个核心概念</span></span><br><span class="line"><span class="comment">Func 是一系列运算(expr)的合集</span></span><br><span class="line"><span class="comment">Var 表达运算中涉及的变量</span></span><br><span class="line"><span class="comment">Expr 表达单个运算过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Halide::Func gradient;</span><br><span class="line">    Halide::Var x, y;</span><br><span class="line">    Halide::Expr e = x + y;</span><br><span class="line"><span class="comment">//这里才完成了函数定义 f(x,y)  = x+ y</span></span><br><span class="line">    gradient(x, y) = e;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面的声明式定义，其实已经体现出Halide是一个新的语言了。</span></span><br><span class="line"><span class="comment">有几个比较细节的点：</span></span><br><span class="line"><span class="comment">1 注意到我们没有对Var x和y进行赋值，就直接在expr中使用它们了。</span></span><br><span class="line"><span class="comment">可以这样做的原因是，它们只是对应二维数组的两个轴向而已，并不代表具体的值。</span></span><br><span class="line"><span class="comment">2 Halide::Expr e = x + y; 中的'='和'+'显然都不是常规语义。这一句实际上构建了一个Halide expr IR节点，op为+，LHS是x，RHS是y；</span></span><br><span class="line"><span class="comment">3 gradient(x, y) = e; 把expr关联到函数上，同样对应了IR上的操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用realize完成了编译和运行，并得到了结果</span></span><br><span class="line">    Halide::Buffer&lt;<span class="keyword">int32_t</span>&gt; output = gradient.realize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="comment">//下面只是校验Halide和通常的运算结果一致</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; output.<span class="built_in">height</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; output.<span class="built_in">width</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output(i, j) != i + j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Something went wrong!\n"</span></span><br><span class="line">                       <span class="string">"Pixel %d, %d was supposed to be %d, but instead it's %d\n"</span>,</span><br><span class="line">                       i, j, i + j, output(i, j));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Success!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，Halide的核心概念就是Func、Var和Expr。它没有文本源代码的格式，直接是寄生在C++上。Func、Var和Expr都是C++的class。在完成声明和赋值的同时，利用对=、+和()的重载，完成了Halide的IR构建。</p>
<h2 id="编译、调试和源码分析"><a href="#编译、调试和源码分析" class="headerlink" title="编译、调试和源码分析"></a>编译、调试和源码分析</h2><h3 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a>编译准备</h3><p>Halide的编译只需要依赖LLVM，在ubuntu18.04上安装llvm8就可以了。<br>clone下Halide代码后，进入目录后执行如下命令，可构建出带有调试信息的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">export CXXFLAGS&#x3D;&quot;-O0 -g3&quot;</span><br><span class="line">export OPTIMIZE&#x3D;&quot;-O0&quot;</span><br><span class="line">make -e -f ..&#x2F;Makefile -j 8</span><br></pre></td></tr></table></figure>
<h3 id="编译示例并调试"><a href="#编译示例并调试" class="headerlink" title="编译示例并调试"></a>编译示例并调试</h3><h4 id="Halide-前端"><a href="#Halide-前端" class="headerlink" title="Halide 前端"></a>Halide 前端</h4><p>在上一步构建完成的build目录中，继续执行如下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd distrib&#x2F;tutorial&#x2F;</span><br><span class="line">g++ lesson_01*.cpp -g -I ..&#x2F;include -L ..&#x2F;bin -lHalide -lpthread -ldl -o lesson_01 -std&#x3D;c++11 -g3</span><br><span class="line">gdb .&#x2F;lesson_01</span><br></pre></td></tr></table></figure>
<p>这个lesson01就是前面语言定义一节中已经给出过的示例代码。<br>由于Function和Var的定义都没有传参，可以跳过，直接单步跟踪expr的赋值。这里给出的结果就非常典型了。<br>首先变量x和y被转换为了Expr。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">15518	    &#x2F;** A Var can be treated as an Expr of type Int(32) *&#x2F;</span><br><span class="line">15519	    operator const Expr &amp;() const &#123;</span><br><span class="line">15520	        return e;</span><br><span class="line">15521	    &#125;</span><br></pre></td></tr></table></figure>
<p>然后Expr的operator+，就调用了Internal::Add::make构建了Expr这个IR。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1139	Expr operator+(Expr a, Expr b) &#123;</span><br><span class="line">1140	    user_assert(a.defined() &amp;&amp; b.defined()) &lt;&lt; &quot;operator+ of undefined Expr\n&quot;;</span><br><span class="line">1141	    Internal::match_types(a, b);</span><br><span class="line">1142	    return Internal::Add::make(std::move(a), std::move(b));</span><br><span class="line">1143	&#125;</span><br><span class="line">---&gt;</span><br><span class="line">21	Expr Add::make(Expr a, Expr b) &#123;</span><br><span class="line">22	    internal_assert(a.defined()) &lt;&lt; &quot;Add of undefined\n&quot;;</span><br><span class="line">23	    internal_assert(b.defined()) &lt;&lt; &quot;Add of undefined\n&quot;;</span><br><span class="line">24	    internal_assert(a.type() &#x3D;&#x3D; b.type()) &lt;&lt; &quot;Add of mismatched types\n&quot;;</span><br><span class="line">25	</span><br><span class="line">(gdb) </span><br><span class="line">26	    Add *node &#x3D; new Add;</span><br><span class="line">27	    node-&gt;type &#x3D; a.type();</span><br><span class="line">28	    node-&gt;a &#x3D; std::move(a);</span><br><span class="line">29	    node-&gt;b &#x3D; std::move(b);</span><br><span class="line">30	    return node;</span><br><span class="line">31	&#125;</span><br></pre></td></tr></table></figure>
<p>调试到这里已经基本能确认Halide前端的工作原理了，通过operator重载，Halide直接构造了IR的，跳过了Lexer和Parser部分。<br>下一个问题是，Halide的IR如何，或者在什么时机进行Codegen。</p>
<h4 id="Halide的代码生成流程"><a href="#Halide的代码生成流程" class="headerlink" title="Halide的代码生成流程"></a>Halide的代码生成流程</h4><p>如前所述，Halide中通过realize方法完成了代码的编译和运行。接着调试上面程序的gradient.realize调用。<br>可以看到如下的调用链条。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#0  Halide::Internal::lower (output_funcs&#x3D;std::vector of length 1, capacity 1 &#x3D; &#123;...&#125;, pipeline_name&#x3D;&quot;f0&quot;, t&#x3D;..., args&#x3D;std::vector of length 1, capacity 1 &#x3D; &#123;...&#125;, </span><br><span class="line">    linkage_type&#x3D;Halide::LinkageType::ExternalPlusMetadata, requirements&#x3D;std::vector of length 0, capacity 0, trace_pipeline&#x3D;false, </span><br><span class="line">    custom_passes&#x3D;std::vector of length 0, capacity 0) at &#x2F;media&#x2F;majiang&#x2F;c6b38ac3-8b8a-4613-8259-dddbffe2f4cb&#x2F;majiang&#x2F;opensource&#x2F;Halide&#x2F;src&#x2F;Lower.cpp:87</span><br><span class="line">#1  0x00007ffff3cb7b6b in Halide::Pipeline::compile_to_module (this&#x3D;0x7fffffffd920, args&#x3D;std::vector of length 1, capacity 1 &#x3D; &#123;...&#125;, fn_name&#x3D;&quot;f0&quot;, target&#x3D;..., </span><br><span class="line">    linkage_type&#x3D;Halide::LinkageType::ExternalPlusMetadata) at &#x2F;media&#x2F;majiang&#x2F;c6b38ac3-8b8a-4613-8259-dddbffe2f4cb&#x2F;majiang&#x2F;opensource&#x2F;Halide&#x2F;src&#x2F;Pipeline.cpp:506</span><br><span class="line">#2  0x00007ffff3cb819b in Halide::Pipeline::compile_jit (this&#x3D;0x7fffffffd920, target_arg&#x3D;...)</span><br><span class="line">    at &#x2F;media&#x2F;majiang&#x2F;c6b38ac3-8b8a-4613-8259-dddbffe2f4cb&#x2F;majiang&#x2F;opensource&#x2F;Halide&#x2F;src&#x2F;Pipeline.cpp:573</span><br><span class="line">#3  0x00007ffff3cbbda7 in Halide::Pipeline::realize (this&#x3D;0x7fffffffd920, outputs&#x3D;..., t&#x3D;..., param_map&#x3D;...)</span><br><span class="line">    at &#x2F;media&#x2F;majiang&#x2F;c6b38ac3-8b8a-4613-8259-dddbffe2f4cb&#x2F;majiang&#x2F;opensource&#x2F;Halide&#x2F;src&#x2F;Pipeline.cpp:1099</span><br><span class="line">#4  0x00007ffff3cb98b0 in Halide::Pipeline::realize (this&#x3D;0x7fffffffd920, sizes&#x3D;std::vector of length 2, capacity 2 &#x3D; &#123;...&#125;, target&#x3D;..., param_map&#x3D;...)</span><br><span class="line">    at &#x2F;media&#x2F;majiang&#x2F;c6b38ac3-8b8a-4613-8259-dddbffe2f4cb&#x2F;majiang&#x2F;opensource&#x2F;Halide&#x2F;src&#x2F;Pipeline.cpp:703</span><br><span class="line">#5  0x00007ffff3ac078c in Halide::Func::realize (this&#x3D;0x7fffffffdbf0, sizes&#x3D;std::vector of length 0, capacity 0, target&#x3D;..., param_map&#x3D;...)</span><br><span class="line">    at &#x2F;media&#x2F;majiang&#x2F;c6b38ac3-8b8a-4613-8259-dddbffe2f4cb&#x2F;majiang&#x2F;opensource&#x2F;Halide&#x2F;src&#x2F;Func.cpp:2922</span><br><span class="line">#6  0x00007ffff3ac0a7d in Halide::Func::realize (this&#x3D;0x7fffffffdbf0, x_size&#x3D;800, y_size&#x3D;600, target&#x3D;..., param_map&#x3D;...)</span><br><span class="line">    at &#x2F;media&#x2F;majiang&#x2F;c6b38ac3-8b8a-4613-8259-dddbffe2f4cb&#x2F;majiang&#x2F;opensource&#x2F;Halide&#x2F;src&#x2F;Func.cpp:2937</span><br><span class="line">#7  0x000055555555d56a in main (argc&#x3D;1, argv&#x3D;0x7fffffffdd98) at lesson_01_basics.cpp:78</span><br></pre></td></tr></table></figure>
<p>看到lower，老司机应该已经心领神会找到门路了。一般lower意味着高层表达向硬件层级扩展，表达的内容将越发具体完整。</p>
<p>lower函数的过程，可以看到大致有两个主要的工作，第一个是补充最终程序需要的系列流程，如初始化环境，建立循环，已经插入一些等等；第二个是进行各项高层优化（优化越接近源码，执行起来越简单。）。但是lower部分看到结尾，仍然没有向另外一种IR或者机器指令转换。<br>从lower返回后，在compile_jit函数中继续向下调试，可以最终找到如下堆栈回溯中，Halide完成了IR到LLVM-IR的codegen过程(当然如果结合代码分析，查找LLVM的相关流程，找到这里会更快)。<br>#0  Halide::Internal::CodeGen_LLVM::compile (this=0x5555557b60e0, input=…)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/CodeGen_LLVM.cpp:637<br>#1  0x00007ffff399a42c in Halide::codegen_llvm (module=…, context=…)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/CodeGen_LLVM.cpp:46<br>#2  0x00007ffff3c326e1 in Halide::compile_module_to_llvm_module (module=…, context=…)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/LLVM_Output.cpp:381<br>#3  0x00007ffff3c13c91 in Halide::Internal::JITModule::JITModule (this=0x7fffffffbf90, m=…, fn=…, dependencies=std::vector of length 0, capacity 0)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/JITModule.cpp:251<br>#4  0x00007ffff3cb86dd in Halide::Pipeline::compile_jit (this=0x7fffffffd920, target_arg=…)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/Pipeline.cpp:607<br>#5  0x00007ffff3cbbda7 in Halide::Pipeline::realize (this=0x7fffffffd920, outputs=…, t=…, param_map=…)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/Pipeline.cpp:1099<br>#6  0x00007ffff3cb98b0 in Halide::Pipeline::realize (this=0x7fffffffd920, sizes=std::vector of length 2, capacity 2 = {…}, target=…, param_map=…)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/Pipeline.cpp:703<br>#7  0x00007ffff3ac078c in Halide::Func::realize (this=0x7fffffffdbf0, sizes=std::vector of length 0, capacity 0, target=…, param_map=…)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/Func.cpp:2922<br>#8  0x00007ffff3ac0a7d in Halide::Func::realize (this=0x7fffffffdbf0, x_size=800, y_size=600, target=…, param_map=…)<br>    at /media/majiang/c6b38ac3-8b8a-4613-8259-dddbffe2f4cb/majiang/opensource/Halide/src/Func.cpp:2937<br>#9  0x000055555555d56a in main (argc=1, argv=0x7fffffffdd98) at lesson_01_basics.cpp:78<br>后面的流程更加直接一些，CodeGen_LLVM.cpp包含了主要的转换内容，compile_func中的    f.body.accept(this); 发起了LLVM-IR的发射动作。<br>后面就是CodeGen_LLVM.cpp中的一堆visit函数完成了针对不同类型Halide IR的LLVMIR代码生成。</p>
<h1 id="遗留的学习"><a href="#遗留的学习" class="headerlink" title="遗留的学习"></a>遗留的学习</h1><p>Halide自带的autotuner如何工作？</p>
<h1 id="有意思的一些编程技巧"><a href="#有意思的一些编程技巧" class="headerlink" title="有意思的一些编程技巧"></a>有意思的一些编程技巧</h1><p>1 把可变参数的输入转成vector处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">HALIDE_NO_USER_CODE_INLINE <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;Internal::all_are_convertible&lt;Var, Args...&gt;::value, FuncRef&gt;::type</span><br><span class="line"><span class="keyword">operator</span>()(Args &amp;&amp;... args) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Var&gt; collected_args&#123;<span class="built_in">std</span>::forward&lt;Args&gt;(args)...&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>()(collected_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 在父类中访问子类成员<br><a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a></p>
<p>Typically, the base class template will take advantage of the fact that member function bodies (definitions) are not instantiated until long after their declarations, and will use members of the derived class within its own member functions, via the use of a cast; e.g.:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;implementation();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        T::static_sub_func();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base&lt;Derived&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">implementation</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_sub_func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/17/HALIDE/" data-id="ckg246lqu001g52fa1xxz0a3x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nvidia_compiler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/16/nvidia_compiler/" class="article-date">
  <time datetime="2020-03-16T03:17:32.000Z" itemprop="datePublished">2020-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/16/nvidia_compiler/">nvidia gpu编译器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/16/nvidia_compiler/" data-id="ckg246lq8000s52fa7fzj4bjz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr10_conclusion" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/llvm_tr10_conclusion/" class="article-date">
  <time datetime="2020-03-13T09:12:57.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/llvm_tr10_conclusion/">Kaleidoscope conclusion</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="总结本次实现待改进点："><a href="#总结本次实现待改进点：" class="headerlink" title="总结本次实现待改进点："></a>总结本次实现待改进点：</h3><p>基本功能：<br>1 补充测试用例（lexer，loc等）,新增系统测试以覆盖更复杂的场景（可以直接参考llvm代码中的test/Examples/Kaleidoscope/Chapter4.test）<br>2 loc中filename冗余消除<br>3 ast的dump功能<br>4 智能指针的使用改进，shared_ptr是否能转回unique？能否实现自动类型转换，避免大量的get？<br>5 添加简单的入参解析流程，help信息改进<br>6 建立行缓冲，在遇到解析错误时，把错误行打印出来，帮助调试<br>7 头文件中using namespace，可能导致污染，需要去掉。<br>8 调试信息bugfix，var/for中的变量还未进行声明，operator = 的信息生成还有问题 (已修复)<br>9 尝试接入方舟的Maple IR，尝试实现Vistor模式<br>…<br>把教程中的一些严重问题，如for的语义，调试信息不正确的问题邮件反馈。</p>
<h3 id="新的有趣扩展"><a href="#新的有趣扩展" class="headerlink" title="新的有趣扩展"></a>新的有趣扩展</h3><p>1 添加global variables实现<br>2 添加类型系统typed variables<br>3 添加arrays, structs, vectors的支持，练习LLVM getelementptr instruction的使用<br>3 实现辅助的runtime功能，例如IO？<br>4 内存管理memory management<br>5 异常支持exception handling support </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/13/llvm_tr10_conclusion/" data-id="ckg246lq2000e52fa2oxz9ju3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr9_debug_info" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/llvm_tr9_debug_info/" class="article-date">
  <time datetime="2020-03-10T11:52:05.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/llvm_tr9_debug_info/">Kaleidoscope debug info</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 调试信息生成时，提到Kaleidoscope语言的abi接近C的abi。从哪里可以明确这一点？</p>
<p>2  source_loc的实现是否合理？有无改进空间？<br>string的存储？</p>
<p>3 能否将core_lib中的operator 先放到parser中解析，完成后再解析输入的用户文件？通过合并ast后再codegen，应该可以静默的实现语言扩展的operator。</p>
<p>4 var变量中的变量是否正确生成了调试信息</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>为减少工作了，剔除原示例悄悄添加的ast dump功能（文字没有介绍，代码新增了）。<br>实现了debug信息的添加，并修复了原实现中的逻辑错误。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现中的主要改动如下：</p>
<p>1 出于节约工作量考虑，删除了原示例中的AST的dump功能，暂未实现；</p>
<p>2<br>原文实现时的调试信息发射有问题，会导致部分指令的调试信息错误。<br>如下binary op的发射代码所示，原示例在函数头部emitLocation，其信息会马上被随后的LHS/RHS codegen覆盖（他们也会emitLocation）。这样一来，真正属于operator的CreateFAdd指令会位于最后一个emitLocation指向的location(也就是RHS的location)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  KSDbgInfo.emitLocation(<span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">"addtmp"</span>);</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用如下的方法编译llvm中的示例代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd llvm-project&#x2F;llvm&#x2F;examples&#x2F;Kaleidoscope&#x2F;Chapter9</span><br><span class="line"> g++ toy.cpp -I ..&#x2F;include&#x2F; -I ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;install&#x2F;usr&#x2F;local&#x2F;include&#x2F; -L..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;install&#x2F;usr&#x2F;local&#x2F;lib &#96;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;install&#x2F;usr&#x2F;local&#x2F;bin&#x2F;llvm-config --libs&#96; -pthread -ldl  -lz -ltinfo -fno-rtti -o toy</span><br></pre></td></tr></table></figure>
<p>然后用下面的测试代码测试toy程序(输入后ctrl+D结束程序)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def binary , 1 (left  right) right</span><br><span class="line"></span><br><span class="line">extern kout(x)</span><br><span class="line">def te(y)</span><br><span class="line">kout(y),</span><br><span class="line">y&#x3D;5,</span><br><span class="line">kout(y)</span><br><span class="line"></span><br><span class="line">def main()</span><br><span class="line">	te(2)</span><br></pre></td></tr></table></figure>
<p>可以获得其输出的LLVM-IR打印如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">define double @te(double %y) !dbg !13 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %y1 &#x3D; alloca double</span><br><span class="line">  call void @llvm.dbg.declare(metadata double* %y1, metadata !17, metadata !DIExpression()), !dbg !18</span><br><span class="line">  store double %y, double* %y1</span><br><span class="line">  %y2 &#x3D; load double, double* %y1, !dbg !19</span><br><span class="line">  %calltmp &#x3D; call double @kout(double %y2), !dbg !19</span><br><span class="line">  store double 5.000000e+00, double* %y1, !dbg !20</span><br><span class="line">  %binop &#x3D; call double @&quot;binary,&quot;(double %calltmp, double 5.000000e+00), !dbg !20</span><br><span class="line">  %y3 &#x3D; load double, double* %y1, !dbg !21</span><br><span class="line">  %calltmp4 &#x3D; call double @kout(double %y3), !dbg !21</span><br><span class="line">  %binop5 &#x3D; call double @&quot;binary,&quot;(double %binop, double %calltmp4), !dbg !21</span><br><span class="line">  ret double %binop5, !dbg !21</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">!13 &#x3D; distinct !DISubprogram(name: &quot;te&quot;, scope: !2, </span><br><span class="line">!20 &#x3D; !DILocation(line: 6, column: 3, scope: !13)</span><br><span class="line">!21 &#x3D; !DILocation(line: 7, column: 6, scope: !13)</span><br></pre></td></tr></table></figure>
<p>可以看到te函数中的两个’,’ operator，其对应的行号都指向了rhs的位置，完全和源代码对不上。<br>使用我们的实现编译代码（因为已经内置了’,’，去掉了其定义）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extern kout(x)</span><br><span class="line"></span><br><span class="line">def te(y)</span><br><span class="line">kout(y),</span><br><span class="line">y&#x3D;5,</span><br><span class="line">kout(y)</span><br><span class="line"></span><br><span class="line">def main()</span><br><span class="line">	te(2)</span><br></pre></td></tr></table></figure>
<p>获得的输出如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">efine double @te(double %y) !dbg !3 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %y1 &#x3D; alloca double</span><br><span class="line">  store double %y, double* %y1, !dbg !9</span><br><span class="line">  call void @llvm.dbg.declare(metadata double* %y1, metadata !8, metadata !DIExpression()), !dbg !10</span><br><span class="line">  %y2 &#x3D; load double, double* %y1, !dbg !11</span><br><span class="line">  %callkout &#x3D; call double @kout(double %y2), !dbg !12</span><br><span class="line">  store double 5.000000e+00, double* %y1, !dbg !13</span><br><span class="line">  %&quot;_binary_,_with_prio_1&quot; &#x3D; call double @&quot;_binary_,_with_prio_1&quot;(double %callkout, double 5.000000e+00), !dbg !12</span><br><span class="line">  %y3 &#x3D; load double, double* %y1, !dbg !14</span><br><span class="line">  %callkout4 &#x3D; call double @kout(double %y3), !dbg !15</span><br><span class="line">  %&quot;_binary_,_with_prio_15&quot; &#x3D; call double @&quot;_binary_,_with_prio_1&quot;(double %&quot;_binary_,_with_prio_1&quot;, double %callkout4), !dbg !13</span><br><span class="line">  ret double %&quot;_binary_,_with_prio_15&quot;, !dbg !13</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">!3 &#x3D; distinct !DISubprogram(name: &quot;te&quot;, scope: !1, file: !1, line: 3, type: !4, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !7)</span><br><span class="line">...</span><br><span class="line">!12 &#x3D; !DILocation(line: 4, column: 8, scope: !3)</span><br><span class="line">!13 &#x3D; !DILocation(line: 5, column: 4, scope: !3)</span><br></pre></td></tr></table></figure>
<p>可以看到，修正后’,’的位置(参考)可以与源代码吻合。<br>  %”<em>binary</em>,<em>with_prio_1” = call double @”_binary</em>,_with_prio_1”(double %callkout, double 5.000000e+00), !dbg !12 这里说明第一个’,’的location在!dbg !12中给出。<br>  而!12 = !DILocation(line: 4, column: 8, scope: !3)准确给出了，’,’在代码的第4行第8列(scope: !3可以继续看到其属于te函数)。</p>
<p>3 为token也添加了location信息，ast的location从token中获取，不直接与lexer打交道层级更清晰。</p>
<p>4 新增了调试信息发射的控制流程和开关变量</p>
<p>5<br>在发射函数的IR时，我们的实现为了方便控制调试信息的发射，<br>将调试信息的发射拆分成了两块。args的调试信息在args的store指令之后发射。<br>这会导致verifyFunction是发生下面错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Expected no forward declarations!</span><br><span class="line">!6 &#x3D; &lt;temporary!&gt; !&#123;&#125;</span><br><span class="line">  store double %x, double* %x1, !dbg !7</span><br><span class="line">  store double %y, double* %y2, !dbg !7</span><br><span class="line">  call void @llvm.dbg.declare(metadata double* %x1, metadata !8, metadata !DIExpression()), !dbg !9</span><br><span class="line">  call void @llvm.dbg.declare(metadata double* %y2, metadata !10, metadata !DIExpression()), !dbg !9</span><br></pre></td></tr></table></figure>
<p>使用 def foo (x y) x+y即可复现。<br>看起来dbg.declare需要放到对应store指令的前面。<br>参考<a href="https://stackoverflow.com/questions/34236034/how-to-track-down-llvm-verifyfunction-error-expected-no-forward-declarations/60656058#60656058后，" target="_blank" rel="noopener">https://stackoverflow.com/questions/34236034/how-to-track-down-llvm-verifyfunction-error-expected-no-forward-declarations/60656058#60656058后，</a><br>在添加verifyFunction前添加finalizeSubprogram，可更正错误。</p>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 调试信息生成时，提到Kaleidoscope语言的abi接近C的abi。从哪里可以明确这一点？<br>语言目前没有明确设计ABI，在LLVM-IR的生成过程中，其实也不需要配置这些内容。当需要具体生成代码时，LLVM的处理流程会用默认值来工作。对于函数的 calling conventions 来说，可以用setCallingConv方法来专门进行设置。通过追踪设置函数可以看到，其初始值应该为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setCallingConv</span><span class="params">(CallingConv::ID CC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ID = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(CC);</span><br><span class="line">    assert(!(ID &amp; ~CallingConv::MaxID) &amp;&amp; <span class="string">"Unsupported calling convention"</span>);</span><br><span class="line">    setValueSubclassData((getSubclassDataFromValue() &amp; <span class="number">0xc00f</span>) | (ID &lt;&lt; <span class="number">4</span>));</span><br><span class="line">  &#125;</span><br><span class="line">---&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValueSubclassData</span><span class="params">(<span class="keyword">unsigned</span> short D)</span> </span>&#123;</span><br><span class="line">    Value::setValueSubclassData(D);</span><br><span class="line">  &#125;</span><br><span class="line">---&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValueSubclassData</span><span class="params">(<span class="keyword">unsigned</span> short D)</span> </span>&#123; SubclassData = D; &#125;</span><br><span class="line">---&gt;</span><br><span class="line">  <span class="comment">/// Hold arbitrary subclass data.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This member is defined by this class, but is not used for anything.</span></span><br><span class="line">  <span class="comment">/// Subclasses can use it to hold whatever state they find useful.  This</span></span><br><span class="line">  <span class="comment">/// field iweizhis initialized to zero by the ctor.</span></span><br><span class="line">  <span class="keyword">unsigned</span> short SubclassData;</span><br></pre></td></tr></table></figure>
<p>  0值对应的意义可以在llvm/IR/CallingConv.h中找到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A set of enums which specify the assigned numeric values for known llvm</span></span><br><span class="line"><span class="comment">/// calling conventions.</span></span><br><span class="line"><span class="comment">/// LLVM Calling Convention Representation</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  <span class="comment">/// C - The default llvm calling convention, compatible with C.  This</span></span><br><span class="line">  <span class="comment">/// convention is the only calling convention that supports varargs calls.</span></span><br><span class="line">  <span class="comment">/// As with typical C calling conventions, the callee/caller have to</span></span><br><span class="line">  <span class="comment">/// tolerate certain amounts of prototype mismatch.</span></span><br><span class="line">  C = <span class="number">0</span>,</span><br></pre></td></tr></table></figure>
<p>这样看起来，原文的说法是基本正确的。在没有设置ABI的情况下，LLVM应该是用了C的配置作为默认值。</p>
<p>2  source_loc的实现是否合理？有无改进空间？<br>为了简单，source_loc当前存在大量的冗余信息。<br>至少其中大量重复的filename string应该合并到一个上，改用idx指向一个vector。<br>最终的方案可能是参考gcc等成熟编译器，将source_loc整个设计为一个idx，要取用的时候再组装成完整的信息。内部储存时，可以合并冗余的string，甚至还可以进一步采用压缩编码方式来记录行号和列号(例如使用基础值+偏移值的方式来记录)。</p>
<p>3 能否将core_lib中的operator 先放到parser中解析，完成后再解析输入的用户文件？通过合并ast后再codegen，应该可以静默的实现语言扩展的operator。<br>可以，但是不能通过合并ast来实现。<br>当前用户自定义operator的功能需要lexer的支持，parse正式代码时lexer不知道新增了哪些operator，会导致unknown token的出现。<br>目前实现的方案是，在parser中静默导入了自定义operator的extern声明，这样用户可以像使用内置operator一样直接使用这些扩展operator。自定义operator的实现放到了core_support_lib中，封装脚本会链入实现。<br>当前实现的主要问题是，operator很多都是短小语句，应该inline优化的，但是拆开成库的形式后，只有lto优化才能达到效果。<br>后续可能的改进是，直接把def定义灌入parser，通过直接修改lexer的loc信息(或者先关掉调试信息输出生成operator定义部分，再codegen剩下的部分)，解决调试信息的冲突问题。</p>
<p>4 var变量中的变量是否正确生成了调试信息<br>没有，原示例var和for中的变量都没有做declare，所以没有对应的调试信息。需要参考args中的处理方法，逐个添加。<br>出于工作量考虑，本次实现也暂时还未添加这些调试信息。</p>
<h3 id="实现中遇到的问题"><a href="#实现中遇到的问题" class="headerlink" title="实现中遇到的问题"></a>实现中遇到的问题</h3><p>1 ranged loop 内部定义的变量，无法跨过循环体保存值。如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line">                &#123;<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="string">":"</span> &lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果将是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:1</span><br><span class="line">0:2</span><br><span class="line">0:3</span><br></pre></td></tr></table></figure>
<p>而不是预期的1:1,2:2,3:3。并且，打开Wall -Wextra时也没有告警。。。</p>
<p>2<br>实现时再次测试了using namespace std;在头文件中的作用范围</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> xx&#123;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;&#125;</span><br><span class="line"><span class="keyword">namespace</span> xx&#123;<span class="function"><span class="keyword">void</span> <span class="title">tt</span><span class="params">()</span> </span>&#123;<span class="built_in">string</span> x;&#125;&#125;</span><br><span class="line"><span class="keyword">namespace</span> xx1&#123;<span class="function"><span class="keyword">void</span> <span class="title">tt</span><span class="params">()</span> </span>&#123;<span class="built_in">string</span> x;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>会报如下错误。说明头文件中的using会污染和其相同的命名空间。控制using namespace的作用范围仍然是一个有意义的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tt.cpp:4:26: error: ‘string’ was not declared in this scope</span><br><span class="line"> namespace xx1&#123;void tt() &#123;string x;&#125;&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/10/llvm_tr9_debug_info/" data-id="ckg246lqm001c52facwwg3xkv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr8_object_generation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/llvm_tr8_object_generation/" class="article-date">
  <time datetime="2020-03-10T02:42:54.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/llvm_tr8_object_generation/">Kaleidoscope object generation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 原示例使用了通用的机器模型进行编译，能否实现针对本地机器的更细粒度优化？</p>
<p>2 能否以较低代价实现支持交叉编译?</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>完成了原示例中的功能。<br>新增了功能：针对native机器的细粒度优化（打开本地cpu支持的特性）。<br>新增了基于环境变量的选项控制功能：默认生成object文件后，可以用选项控制保留LLVM-IR中间文件。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现的两个主要变更：<br>1<br>原示例基于通用cpu的特性来生成代码，优化没有充分利用本地cpu的能力。本次实现改为了基于native去探测本地cpu的能力，选择最合适的指令（相当于使用l了-march=native）。具体实现过程使用了llvm/CodeGen/CommandFlags.inc中的getCPUStr函数来探测cpu。但是该inc文件似乎并不是一个稳定的开放接口文件，在工程内多次包含启动时会有冲突，同时其设置内部变量的方法也比较粗暴。实现时通过将其隔离到单个cpp文件来规避了该问题，可能并不是最好的解决方法。</p>
<p>2<br>添加object文件生成功能后，按照编译器的通常约定，将默认输出从LLVM-IR修改为object文件。同时，为了调试编译器本身的逻辑，查看编译过程中生成的LLVM-IR也是很有帮助的。<br>为了支持这样的控制逻辑，添加了一个基于环境变量的选项控制框架。实现代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">control_flags</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flag_item</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		T flag_val;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* input_env;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* description;</span><br><span class="line">		flag_item(T default_val, <span class="keyword">const</span> <span class="keyword">char</span>* env, <span class="keyword">const</span> <span class="keyword">char</span>* des) :</span><br><span class="line">			input_env(env), description(des)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *env_val = getenv(input_env);</span><br><span class="line">			<span class="keyword">if</span> (env_val != <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">stringstream</span> tmp;</span><br><span class="line">				tmp &lt;&lt; env_val;</span><br><span class="line">				tmp &gt;&gt; flag_val;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				flag_val = default_val;</span><br><span class="line">		&#125;</span><br><span class="line">		flag_item()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> flag_val;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECL_FLAG(flag_type, flag_name, default_val, input_env, des) \</span></span><br><span class="line">	flag_item&lt;flag_type&gt; flag_name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"flags.def"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECL_FLAG</span></span><br><span class="line">	control_flags()</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECL_FLAG(flag_type, flag_name, default_val, input_env, des) \</span></span><br><span class="line">	flag_item&lt;flag_type&gt; flag_name#<span class="meta">#cons(default_val, input_env, des);\</span></span><br><span class="line">	flag_name = flag_name##cons;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"flags.def"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECL_FLAG</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;global_flags;</span><br></pre></td></tr></table></figure>
<p>其基本思路很简单，借鉴自golang编译器的实践。从环境变量中获取输入，避开繁琐的输入选项解析。再利用sstream提供的通用类型转换功能，可以完成大多数情况下的flag数值设置。后续只需要按需增加callback函数做输入的合法性检查即可。<br>在此框架下添加控制选项只需新增如下一行即可。引用flags时，只需将定义一个全局变量 control_flags global_flag，然后引用global_flag.save_temps等名称即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量类型，变量名称，变量默认值，用于控制该变量的环境变量名称，变量作用描述</span></span><br><span class="line">DECL_FLAG(<span class="keyword">bool</span>, save_temps, <span class="literal">false</span>, <span class="string">"save_temps"</span>, <span class="string">"keep intermediate files"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 原示例使用了通用的机器模型进行编译，能否实现针对本地机器的更细粒度优化？<br>使用llvm提供的机制即可自动探测本地cpu的能力，细节可参考实现1中的描述。</p>
<p>2 能否以较低代价实现支持交叉编译?<br>llvm框架中交叉编译是默认配置，本地配置只不过一种特化场景。因此，要支持交叉编译非常容易，只需要新增一个入参指定目标代码的三元组TargetTriple(如x86_64-linux-gnu)即可。但是考虑到新增这个特性后，需要一并添加正确性检查，修改optimizer中的逻辑，工作量稍大。在完成主体工作前，可以稍缓一点实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/10/llvm_tr8_object_generation/" data-id="ckg246lq7000p52fa4mtiajbw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr7_mutable_variables" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/llvm_tr7_mutable_variables/" class="article-date">
  <time datetime="2020-03-02T13:15:01.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/llvm_tr7_mutable_variables/">Kaleidoscope mutable variable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 使用CreateAlloca在function的头部创建栈空间，是否会导致不必要的额外栈空间占用？</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>完成了原示例的功能，添加了对应的简单测试。<br>以库的方式添加了’,’和’!=’等核心的operator，尚未自动添加到源代码中。<br>一种可行的简单方式是以源代码方式直接把这些operator的def直接include到代码的头部，然后再编译。但是，需要考虑这样操作对源代码行号的干扰。<br>等待后续生成调试信息的章节一并考虑。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现时做了如下两个主要的改进:<br>1 var中变量默认数值设置为0，原示例是在LLVM-IR 生成时构造的。从逻辑上看，这个应该是语法层面的规定，不应该放到codegen的流程中决定。本次实现时，在parser中parse_var时将未初始化的变量value设置为了0。codegen时只管按值生成就可以了。<br>2 在处理var中的变量shadow前面已定义变量的情况时。原示例为了简单，是直接把var中声明的所有变量都缓冲到了OldBindings中，如果没有shadow，则把nullptr缓冲到OldBindings中。生成完body后，直接把OldBindings中的所有条目写回NamedValues中。如下片段所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;AllocaInst *&gt; OldBindings;</span><br><span class="line">  OldBindings.push_back(NamedValues[VarName]);</span><br><span class="line">  <span class="comment">// Remember this binding.</span></span><br><span class="line">  NamedValues[VarName] = Alloca;</span><br><span class="line">....body_gen....</span><br><span class="line">  <span class="comment">// Pop all our variables from scope.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = VarNames.<span class="built_in">size</span>(); i != e; ++i)</span><br><span class="line">    NamedValues[VarNames[i].first] = OldBindings[i];</span><br></pre></td></tr></table></figure>
<p>本次实现使用了更安全的find来替代[] operator，同时改进了缓存结构。<br>通过存储named_var中被shadow变量alloca字段的地址，消除了恢复<br>named_var时的map查找动作，如下片段所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;AllocaInst **, AllocaInst *&gt;&gt; saved_name_vec;</span><br><span class="line">....</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = named_var.<span class="built_in">find</span>(var_name); it != named_var.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			saved_name_vec.push_back(</span><br><span class="line">				<span class="built_in">std</span>::make_pair(&amp;(it-&gt;second), it-&gt;second));</span><br><span class="line">			it-&gt;second = var_allocas[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			named_var[var_name] = var_allocas[i];</span><br><span class="line">	&#125;</span><br><span class="line">...bodygen....</span><br><span class="line"><span class="comment">//恢复named_var</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; saved_name_vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> old_alloca_addr = saved_name_vec[i].first;</span><br><span class="line">		*old_alloca_addr = saved_name_vec[i].second;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3 实现测试时发现了原示例中存在内存泄漏的可能，如下代码所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">IfExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// Create blocks for the then and else cases.  Insert the 'then' block at the</span></span><br><span class="line">  <span class="comment">// end of the function.</span></span><br><span class="line">  BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class="string">"then"</span>, TheFunction);</span><br><span class="line">  BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class="string">"else"</span>);</span><br><span class="line">  BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class="string">"ifcont"</span>);</span><br><span class="line">....</span><br><span class="line">  Value *ThenV = Then-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!ThenV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码片段中，ElseBB和MergeBB创建后没有立即挂入function的链表中。如果函数在类似于ThenV的异常流程中return了，则没有人能释放掉这两个指针了。我们的实现中也有类似问题。<br>要比较完整的修复该问题，有两个点需要同时考虑：<br>首先，BB创建后都立即挂到Function中去是否会有不良影响？如果没有，创建就挂上是最好的解决方案；<br>如果不能立即挂上，除了在函数内考虑释放资源外，还要考虑    ir_builder.CreateBr(merge_bb);等语句在异常发生时可能引用悬空指针的问题。需要重排对这些指针的引用，将其都放到末尾。</p>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 使用CreateAlloca在function的头部创建栈空间，是否会导致不必要的额外栈空间占用？<br>使用如下的c语言片段进行了测试。发现clang生成代码时也会把alloca都放到头部，并且生成的x86-64和mips64的代码也都是一次在头部把sp预留够。<br>这里的权衡可能是动态扩展栈变量无法节约多少内存，但是会浪费操作sp的指令，另外也使得分析stack frame变得更为困难，得不偿失。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (x)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">char</span> nb[<span class="number">1024</span>]= &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现中遇到的问题"><a href="#实现中遇到的问题" class="headerlink" title="实现中遇到的问题"></a>实现中遇到的问题</h3><p>1 map 的operator[]会改写原map<br>在改写for代码生成流程中，named_var map 记录和恢复idt var的部分时，<br>注意到了下面一对代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">auto</span> old_val = named_var[idt_name];</span><br><span class="line">	named_var[idt_name] = idt_var;</span><br><span class="line">.....</span><br><span class="line">	<span class="keyword">if</span> (old_val != <span class="literal">nullptr</span>)</span><br><span class="line">		named_var[idt_name] = old_val;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		named_var.erase(idt_name);</span><br></pre></td></tr></table></figure>
<p>这段逻辑是直接从原示例中拷贝过来的。<br>重构时注意到named_var[idt_name]的初始值问题。<br>当idt_name这个key不在map中时，读取其value的语义是比较模糊的。<br>参考<a href="https://en.cppreference.com/w/cpp/container/map/operator_at" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/container/map/operator_at</a> ， 发现[]这个operator竟然会静默的insert，即使这个operator是用在取右值的动作中。<br>用下面的示例，可以较为直观展示出这个出人意料的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>*&gt; t1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size before access:"</span> &lt;&lt; t1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"uninitialized pointer is: "</span> &lt;&lt; t1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size after access:"</span> &lt;&lt; t1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"count after access:"</span> &lt;&lt; t1.count(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的输出如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size before access:0</span><br><span class="line">uninitialized pointer is: 0</span><br><span class="line">size after access:1</span><br><span class="line">count after access:1</span><br></pre></td></tr></table></figure>
<p>可以看到使用[]访问map时，确实会有insert的动作，并且当key不在map中时，返回的vale是一个默认初始化的值。<br>在这样的语义下，原示例的代码片段虽然不会导致严重的逻辑错误，但是仍有两个明显的问题。<br>第一，引入了冗余的insert动作，拖慢了编译器工作速度。<br>第二，在退出清理map时，如果初始key不存在就不会erase。这样一来map中会残留一个错误的映射项目idt_var –&gt; nullptr。后续流程如果直接使用count这类存在性接口去测试，会得到错误的结果。这是一个潜在的错误来源。</p>
<p>2 std::move作用于const vector不生效<br>如下测试代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testc_ref</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inner;</span><br><span class="line">    testc_ref(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in) : inner(<span class="built_in">std</span>::<span class="built_in">move</span>(in)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testc_move</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inner;</span><br><span class="line">    testc_move(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in) : inner(<span class="built_in">std</span>::<span class="built_in">move</span>(in)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testc_const_ref</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inner;</span><br><span class="line">    testc_const_ref(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in) : inner(<span class="built_in">std</span>::<span class="built_in">move</span>(in)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mytest</span><span class="params">(<span class="number">100000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"org:"</span> &lt;&lt; &amp;(mytest[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">testc_move <span class="title">t1</span><span class="params">(mytest)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1:"</span>&lt;&lt; &amp;(t1.inner[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;(mytest[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">testc_move <span class="title">t2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(mytest))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t2:"</span>&lt;&lt; &amp;(t2.inner[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;(mytest[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mytest1</span><span class="params">(<span class="number">100000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"org:"</span> &lt;&lt; &amp;(mytest1[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">testc_ref <span class="title">t3</span><span class="params">(mytest1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t3:"</span>&lt;&lt; &amp;(t3.inner[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;(mytest1[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mytest2</span><span class="params">(<span class="number">100000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"org:"</span> &lt;&lt; &amp;(mytest2[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">testc_const_ref <span class="title">t4</span><span class="params">(mytest2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t4:"</span>&lt;&lt; &amp;(t4.inner[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;(mytest2[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的输出为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">org:0x7f39d2d5f010</span><br><span class="line">t1:0x7f39d2cfd010</span><br><span class="line">0x7f39d2d5f010</span><br><span class="line">t2:0x7f39d2d5f010</span><br><span class="line">0</span><br><span class="line">org:0x7f39d2c9b010</span><br><span class="line">t3:0x7f39d2c9b010</span><br><span class="line">0</span><br><span class="line">org:0x7f39d2c39010</span><br><span class="line">t4:0x7f39d1e45010</span><br><span class="line">0x7f39d2c39010</span><br></pre></td></tr></table></figure>
<p>==可以看出按值传参时需要在调用点和内部都用move才能避免内存分配。==<br>==按引用传参时，只需在子函数内move即可。==<br>==而以const 引用传参时，move不会生效，并且也不会有任何告警。==</p>
<p>3 如何使用string_view作为key来访问string为key的map<br>需要使用map&lt;string, int, less&lt;&gt;&gt;这样的方式建立map，否则find必须使用string做key。<br>当使用map&lt;string, int, less&lt;&gt;&gt; 建立map时，调用find实际上是把string_view透传到std:less这个模板中。<br>后续在find的过程中，less会把map中每一个待比较的string转为string_view，然后进行两个string_view的比较。<br>如果是调用find的时候，把string_view先转为string再传入，则find内部就不再需要构建临时object。<br>使用下面的示例进行对比测试，使用string_view的版本由于有string转string_view的过程，其速度要略微慢于string的版本。下面是g++-7 -O2编译的结果。性能差距在1%以内。<br> ./t3   string_view<br>102400<br>Time taken by function: 1254672 microseconds<br>./t4    string版本<br>102400<br>Time taken by function: 1243754 microseconds</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string_view key = <span class="string">"hello"</span>;   <span class="comment">//string key = "hello"</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>, less&lt;&gt;&gt; coll;  <span class="comment">//map&lt;string, int&gt; coll;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">102400</span>;i++)</span><br><span class="line">        coll.insert(make_pair(to_string(i),i));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; coll.<span class="built_in">size</span>()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">unsigned</span> rep = <span class="number">1024</span>*<span class="number">1024</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> re = coll.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">auto</span> start = high_resolution_clock::now(); </span><br><span class="line">    <span class="keyword">while</span> (rep--)</span><br><span class="line">    &#123;</span><br><span class="line">        re = coll.<span class="built_in">find</span>(key); <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">stop</span> = high_resolution_clock::now(); </span><br><span class="line">    <span class="keyword">auto</span> duration = duration_cast&lt;microseconds&gt;(<span class="built_in">stop</span> - start); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time taken by function: "</span></span><br><span class="line">        &lt;&lt; duration.count() &lt;&lt; <span class="string">" microseconds"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/02/llvm_tr7_mutable_variables/" data-id="ckg246lql001a52fab5m0ewua" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo升级和添加图片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/hexo%E5%8D%87%E7%BA%A7%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/" class="article-date">
  <time datetime="2020-03-02T03:12:42.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/hexo%E5%8D%87%E7%BA%A7%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/">hexo升级和插入图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="插入图片失败"><a href="#插入图片失败" class="headerlink" title="插入图片失败"></a>插入图片失败</h1><p>参考<a href="https://blog.csdn.net/u010996565/article/details/89196612" target="_blank" rel="noopener">https://blog.csdn.net/u010996565/article/details/89196612</a> 等文章的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>然后在文本中插入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;图片名&quot;  width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot;&gt;</span><br><span class="line">![](image图片名)</span><br></pre></td></tr></table></figure>
<p>均无法正确显示图片。<br>hexo sever启动的终端可以看到如下提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update link as:--&gt;&#x2F;.com&#x2F;&#x2F;xxxx.png</span><br></pre></td></tr></table></figure>
<p>打开图片的地址也是/.com//xxxx.png。<br>搜索到如下的网页介绍了类似的问题。<br><a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br>但是其提供的方案也无法生效。<br>考虑到安装 hexo-asset-image时曾经提到需要hexo4.0以上版本，而当前hexo版本是3.9，所以考虑先行升级版本</p>
<h1 id="升级hexo"><a href="#升级hexo" class="headerlink" title="升级hexo"></a>升级hexo</h1><p>参考如下链接<br><a href="https://www.dazhuanlan.com/2020/01/29/5e3165c116e0f/?__cf_chl_jschl_tk__=e7caf23cde91dcc1f9fc6e1006b88d0bf63de758-1584498843-0-AQ7fucDfahofVnETCllMEC0jJ8Wrecp_5-NxLutNm_NE07_6SkOP9aYE2mlgJv6oQ9Z78RVSuvf1uZBXN-AwXQ898WXTdcE5uf90w-_XCgWONaii4YIUO62_6vLfMSqvz4miZBzOpMYwmaop6pjkWnQWyhJIsJ-LkHyQXZPBRAteDLBEWZ1-gkaq3aXBT4DZl6-I2wJ_R1WFiBqHDlBlrr2treoeNxPspJpjB0L5Qzd1-8JtGPUprKEBt2KCKCjAXtWL9NZ6TJb93L6wrwpWsJdY45QkNxfwTYq6NPOPd4H3suwbWr1P_FY2lWzbk7NfwQ" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/01/29/5e3165c116e0f/?__cf_chl_jschl_tk__=e7caf23cde91dcc1f9fc6e1006b88d0bf63de758-1584498843-0-AQ7fucDfahofVnETCllMEC0jJ8Wrecp_5-NxLutNm_NE07_6SkOP9aYE2mlgJv6oQ9Z78RVSuvf1uZBXN-AwXQ898WXTdcE5uf90w-_XCgWONaii4YIUO62_6vLfMSqvz4miZBzOpMYwmaop6pjkWnQWyhJIsJ-LkHyQXZPBRAteDLBEWZ1-gkaq3aXBT4DZl6-I2wJ_R1WFiBqHDlBlrr2treoeNxPspJpjB0L5Qzd1-8JtGPUprKEBt2KCKCjAXtWL9NZ6TJb93L6wrwpWsJdY45QkNxfwTYq6NPOPd4H3suwbWr1P_FY2lWzbk7NfwQ</a><br>使用如下步骤，将hexo升级到了4.2.0<br>1 清除node的cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure>
<p>2 安装node版本管理工具 n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure>
<p>3 安装最新稳定版本的node</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n stable</span><br></pre></td></tr></table></figure>
<p>// 安装最新版本使用 n latest<br>// 安装指定版本的使用 n {version}，例如 n 11.2.0<br>// 删除指定版本的node使用 n rm {version}，例如 n rm 11.2.0<br>4 更新npm版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm@latest -g</span><br></pre></td></tr></table></figure>
<p>5 进入blog目录，然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure>
<p>6  根据第5步输出，手工记录各个组件的最新版本号，然后逐一在package.json配置文件中修改版本号到最新版本。</p>
<p>7 更新模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save</span><br></pre></td></tr></table></figure>
<p>8 确认升级结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<h1 id="升级后的问题解决"><a href="#升级后的问题解决" class="headerlink" title="升级后的问题解决"></a>升级后的问题解决</h1><p>升级后图片仍然无法正常显示。<br>异常现象变为，路径正常时，网页上就直接显示路径文本，而不是显示图片。<br>而使用部分博客提到的语法，则生成的网页中直接就是空白（查看html文件，整段内容直接被忽略了）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img slug [title] %&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到部分博客提到hexo4.0把很多插件并入了核心代码，担心插件中有冲突，于是使用下面的命令卸载掉第三方插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-asset-link --save</span><br><span class="line">npm remove hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>然后再在文件中使用markdown的语法，就能正确显示图片了。<br>并且主页中的图片也能正常显示，应该是hexo4.0把image link并入核心代码后做了改进（pacakge.json中显示多了一个hexo-image-link组件），解决了markdown语法的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt Text](图片文件 &quot;Title Text&quot;)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/02/hexo%E5%8D%87%E7%BA%A7%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/" data-id="ckg246lq1000a52fa8muj5q2j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-elf_go" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/elf_go/" class="article-date">
  <time datetime="2020-03-02T03:12:42.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/elf_go/">ELFGO 编译和测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><pre><code>从https://github.com/pytorch/ELF 下载代码
在ELF的根目录下git submodule sync &amp;&amp; git submodule update --init --recursive获取第三方代码</code></pre><h2 id="使用docker方式进行构建"><a href="#使用docker方式进行构建" class="headerlink" title="使用docker方式进行构建"></a>使用docker方式进行构建</h2><pre><code>为减少对本地系统的冲击，可以使用docker 方式构建。
先进入ELF的根目录。
在编译前，需要对Dockerfile做一些小调整。
在原来的conda install后新增如下一行
RUN conda install pytorch torchvision cudatoolkit=10.0 -c pytorch
然后使用如下命令进行构建 (为了下载提速，挂了代理)
sudo docker build --network host  --build-arg HTTP_PROXY=socks5://127.0.0.1:1080 --build-arg HTTPS_PROXY=socks5://127.0.0.1:1080 -t elf_go:vtrunk .</code></pre><h1 id="运行时问题解决"><a href="#运行时问题解决" class="headerlink" title="运行时问题解决"></a>运行时问题解决</h1><h2 id="启动制作好的image，拷贝到host中，以便使用GPU"><a href="#启动制作好的image，拷贝到host中，以便使用GPU" class="headerlink" title="启动制作好的image，拷贝到host中，以便使用GPU"></a>启动制作好的image，拷贝到host中，以便使用GPU</h2><pre><code>sudo docker images 查看刚刚构建出的镜像id
启动如下的示例命令启动image，然后将我们需要的内容拷贝到host上</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker  run  -dit  --name elf_go  $&#123;your_image_id&#125;</span><br><span class="line">sudo docker cp elf_go:&#x2F;go-elf $&#123;your_host_elf_dir&#125;</span><br></pre></td></tr></table></figure>
<h2 id="准备host机的路径"><a href="#准备host机的路径" class="headerlink" title="准备host机的路径"></a>准备host机的路径</h2><pre><code>由于docker构建时使用了root用户，构建出的binary依赖了一些根路径下的目录。有很多办法可以解决这类问题。
治本的方案是修改编译体系，去除这些对根目录的依赖，将一个用户可控制目录作为根目录(或者使用相对路径)。但是修改的工作量比较大。
规避的办法也有一些，使用patchelf可以修改一些搜索路径，也可以考虑使用fakeroot等技术重定向文件访问的路径。修改的工作量还是略大。
这里用最粗暴的方法，用mount bind来建立一个满足访问要求的映射路径。
先行建立所需的路径。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;root&#x2F;miniconda3</span><br><span class="line">sudo mkdir &#x2F;go-elf</span><br></pre></td></tr></table></figure>
<pre><code>进入到我们拷贝路径${your_host_elf_dir}，使用如下命令完成映射</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o bind .&#x2F;miniconda3&#x2F; &#x2F;root&#x2F;miniconda3</span><br><span class="line">sudo mount -o bind .&#x2F;go-elf  &#x2F;go-elf</span><br></pre></td></tr></table></figure>
<p>最后设置搜索路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;root&#x2F;miniconda3&#x2F;bin</span><br></pre></td></tr></table></figure>
<h2 id="下载v2版本模型"><a href="#下载v2版本模型" class="headerlink" title="下载v2版本模型"></a>下载v2版本模型</h2><pre><code>主线elf版本只能使用v2版本的模型，Dockerfile中下载的v0版本无法使用。可从</code></pre><p><a href="https://dl.fbaipublicfiles.com/elfopengo/pretrained_models/pretrained-go-19x19-v2.bin" target="_blank" rel="noopener">https://dl.fbaipublicfiles.com/elfopengo/pretrained_models/pretrained-go-19x19-v2.bin</a> 下载后，放入${your_host_elf_dir}/go-elf/ELF中。</p>
<h2 id="适配python版本"><a href="#适配python版本" class="headerlink" title="适配python版本"></a>适配python版本</h2><pre><code>elf构建时docker内使用的python版本可能和host中的不一致。需要修改/go-elf/ELF/scripts/elfgames/go/gtp.sh中的启动命令，确保使用(dockerfile构建时)conda中安装的python版本。</code></pre><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">majiang@majiang-All-Series:~/hd/opensource/ELF_GO/builded_env/go-elf/ELF/scripts/elfgames/go$ git diff gtp.sh </span><br><span class="line">diff --git a/scripts/elfgames/go/gtp.sh b/scripts/elfgames/go/gtp.sh</span><br><span class="line">index 0ca7aba..3291ade 100755</span><br><span class="line"><span class="comment">--- a/scripts/elfgames/go/gtp.sh</span></span><br><span class="line"><span class="comment">+++ b/scripts/elfgames/go/gtp.sh</span></span><br><span class="line"><span class="meta">@@ -9,7 +9,7 @@</span></span><br><span class="line"> MODEL=$1</span><br><span class="line"> shift</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-game=elfgames.go.game model=df_pred model_file=elfgames.go.df_model3 python3 df_console.py --mode online --keys_in_reply V rv \</span></span><br><span class="line"><span class="addition">+game=elfgames.go.game model=df_pred model_file=elfgames.go.df_model3 python3.7 df_console.py --mode online --keys_in_reply V rv \</span></span><br><span class="line">     --use_mcts --mcts_verbose_time --mcts_use_prior --mcts_persistent_tree --load $MODEL \</span><br><span class="line">     --server_addr localhost --port 1234 \</span><br><span class="line">     --replace_prefix resnet.module,resnet init_conv.module,init_conv \</span><br></pre></td></tr></table></figure>
<pre><code>如果出现python版本不匹配问题，可能出现一些莫名其妙的模块找不到错误，如下所示。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#39;torch._C&#39;</span><br></pre></td></tr></table></figure>
<pre><code>其原因是，python的动态库对python版本有依赖，参考https://github.com/pytorch/pytorch/issues/574。host机器的python3如果不是conda所用的python3.7就会出现找不到库问题。</code></pre><h2 id="启动elf自带的脚本"><a href="#启动elf自带的脚本" class="headerlink" title="启动elf自带的脚本"></a>启动elf自带的脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;go-elf&#x2F;ELF&#x2F;scripts</span><br><span class="line">source devmode_set_pythonpath.sh</span><br><span class="line">cd &#x2F;go-elf&#x2F;ELF&#x2F;scripts&#x2F;elfgames&#x2F;go&#x2F;</span><br><span class="line">.&#x2F;gtp.sh ..&#x2F;..&#x2F;..&#x2F;pretrained-go-19x19-v2.bin --loglevel off --gpu 0 --num_block 20 --dim 256 --mcts_puct 1.50 --batchsize 256 --mcts_rollout_per_batch 16 --mcts_threads 2 --mcts_rollout_per_thread 8192 --resign_thres 0.05 --mcts_virtual_loss 1</span><br></pre></td></tr></table></figure>
<h2 id="解决代码问题"><a href="#解决代码问题" class="headerlink" title="解决代码问题"></a>解决代码问题</h2><h3 id="v-pin-memory-处的cuda-out-of-memory问题"><a href="#v-pin-memory-处的cuda-out-of-memory问题" class="headerlink" title="v.pin_memory()处的cuda out of memory问题"></a>v.pin_memory()处的cuda out of memory问题</h3><p>加了print (v)语句。go-elf/ELF/src_py/elf/utils_elf.py 44行<br>            print (v)<br>            if gpu is not None:<br>                with torch.cuda.device(gpu):<br>                    v = v.pin_memory()<br>            v.fill_(1)<br>似乎是偶发故障，后续没有再复现</p>
<h3 id="启动后使用genmove-B开始下棋，utils-elf-py-210出现了数据维度不匹配的问题"><a href="#启动后使用genmove-B开始下棋，utils-elf-py-210出现了数据维度不匹配的问题" class="headerlink" title="启动后使用genmove B开始下棋，utils_elf.py 210出现了数据维度不匹配的问题"></a>启动后使用genmove B开始下棋，utils_elf.py 210出现了数据维度不匹配的问题</h3><p>genmove B会有异常，经过检查可能是下面utils_elf.py 210出现了数据维度不匹配的问题，修改接口后解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#bk[:] &#x3D; v.squeeze_()</span><br><span class="line">bk[:] &#x3D; v.squeeze()</span><br></pre></td></tr></table></figure>
<p>错误现象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py(192)copy_from()</span><br><span class="line">-&gt; for k, v in this_src.items():</span><br><span class="line">(Pdb) y</span><br><span class="line">*** NameError: name &#39;y&#39; is not defined</span><br><span class="line">(Pdb) q</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;df_console.py&quot;, line 86, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;df_console.py&quot;, line 79, in main</span><br><span class="line">    GC.run()</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py&quot;, line 436, in run</span><br><span class="line">    self._call(smem, *args, **kwargs)</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py&quot;, line 404, in _call</span><br><span class="line">    keys_extra, keys_missing &#x3D; sel_reply.copy_from(reply)</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py&quot;, line 192, in copy_from</span><br><span class="line">    for k, v in this_src.items():</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;go-elf&#x2F;ELF&#x2F;src_py&#x2F;elf&#x2F;utils_elf.py&quot;, line 192, in copy_from</span><br><span class="line">    for k, v in this_src.items():</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;miniconda3&#x2F;lib&#x2F;python3.7&#x2F;bdb.py&quot;, line 88, in trace_dispatch</span><br><span class="line">    return self.dispatch_line(frame)</span><br><span class="line">  File &quot;&#x2F;home&#x2F;majiang&#x2F;hd&#x2F;opensource&#x2F;ELF_GO&#x2F;builded_env&#x2F;miniconda3&#x2F;lib&#x2F;python3.7&#x2F;bdb.py&quot;, line 113, in dispatch_line</span><br><span class="line">    if self.quitting: raise BdbQuit</span><br></pre></td></tr></table></figure>
<h1 id="GTP协议问题"><a href="#GTP协议问题" class="headerlink" title="GTP协议问题"></a>GTP协议问题</h1><p>gtp脚本启动后可以在文本界面下使用GTP协议的指令下棋了。<br>但是sabaki围棋前端界面无法正常与eflgo进行GTP通信。<br>查看GTP协议，是ELFGO的额外打印干扰了协议解析。<br>参考<a href="https://github.com/pytorch/ELF/compare/master...Narsil:master，调整了console_lib.py" target="_blank" rel="noopener">https://github.com/pytorch/ELF/compare/master...Narsil:master，调整了console_lib.py</a> 中的</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    def print_msg(self, ret, msg):</span><br><span class="line"><span class="deletion">-        print("\n%s %s\n\n" % (("=" if ret else "?"), msg))</span></span><br><span class="line"><span class="addition">+        print("%s %s\n\n" % (("=" if ret else "?"), msg))</span></span><br></pre></td></tr></table></figure>
<p>启动gtp脚本时，可以添加–loglevel off选项关闭大量额外打印。</p>
<h1 id="封装脚本"><a href="#封装脚本" class="headerlink" title="封装脚本"></a>封装脚本</h1><p>为了sabaki等前端能比较方便的启动ELFGO后端，可以使用如下的封装脚本一次完成启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> -x</span></span><br><span class="line">cur_shell_dir="$( cd "$( dirname "$&#123;BASH_SOURCE[0]&#125;" )" &amp;&amp; pwd )"</span><br><span class="line">cd $&#123;cur_shell_dir&#125;</span><br><span class="line"></span><br><span class="line">cd ../../../../../</span><br><span class="line">sudo mount -o bind ./miniconda3/ /root/miniconda3</span><br><span class="line">sudo mount -o bind ./go-elf  /go-elf</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/root/miniconda3/bin</span><br><span class="line">cd ../../</span><br><span class="line">source devmode_set_pythonpath.sh</span><br><span class="line">cd -</span><br><span class="line">./gtp.sh ../../../pretrained-go-19x19-v2.bin --loglevel off --gpu 0 --num_block 20 --dim 256 --mcts_puct 1.50 --batchsize 256 --mcts_rollout_per_batch 16 --mcts_threads 2 --mcts_rollout_per_thread 8192 --resign_thres 0.05 --mcts_virtual_loss 1</span><br></pre></td></tr></table></figure>

<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>在sabaki中，当前elfgo还是只能 执黑。如果执白还是会卡死，可能协议文本的输出还有问题。<br>另外，说明中提到elfgo只能走贴7.5目的规则。</p>
<h1 id="另一个围棋AI，可以给出胜率估计的leela-zero"><a href="#另一个围棋AI，可以给出胜率估计的leela-zero" class="headerlink" title="另一个围棋AI，可以给出胜率估计的leela-zero"></a>另一个围棋AI，可以给出胜率估计的leela-zero</h1><p>下载并解压Lizzie.0.7.2.Mac-Linux.zip，然后进入解压后的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy&#x3D;&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">export https_proxy&#x3D;&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gcp&#x2F;leela-zero</span><br><span class="line">cd leela-zero</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">sudo apt install libboost-dev libboost-program-options-dev libopenblas-dev opencl-headers ocl-icd-libopencl1 ocl-icd-opencl-dev zlib1g-dev</span><br><span class="line">sudo apt install cmake g++ libboost-dev libboost-program-options-dev libboost-filesystem-dev opencl-headers ocl-icd-libopencl1 ocl-icd-opencl-dev zlib1g-dev</span><br><span class="line">mkdir build</span><br><span class="line">cmake ..&#x2F;</span><br><span class="line">...</span><br><span class="line">CMake Warning at CMakeLists.txt:129 (message):</span><br><span class="line">  Qt is not found, build for &#96;autogtp&#96; and &#96;validation&#96; is disabled</span><br><span class="line">...</span><br><span class="line">cmake --build .</span><br><span class="line">cd ..&#x2F;..&#x2F;</span><br><span class="line">cp .&#x2F;leela-zero&#x2F;build&#x2F;leelaz .&#x2F;</span><br><span class="line">chmod +x  .&#x2F;lizzie.jar</span><br><span class="line">.&#x2F;lizzie.jar</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/03/02/elf_go/" data-id="ckg246lqk001652fae5ieb3jw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-llvm_tr6_user_defined_operator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/21/llvm_tr6_user_defined_operator/" class="article-date">
  <time datetime="2020-02-21T10:22:51.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/llvm_tr6_user_defined_operator/">Kaleidoscope user defined operator</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>完成对 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.html" target="_blank" rel="noopener">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.html</a> 的学习。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>看懂原网页后，实现同样的功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1 命名时没有限制operator是否能是常规字符(如abc,123等)，会否产生静默的关键字冲突？<br>2 考虑如何处理两个特殊字符组成的操作符，如==　!=等。<br>3 示例中的自定义operator是否能作为库使用？如果不能应该如何改进？</p>
<h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>完成了原示例自定义binary和unary operator的功能，但是未支持用户定义”unary-“。<br>尚未支持unary-的原因是为了阻止用户犯错，我们禁止了用户定义使用保护字符（包括内置运算符、分隔符等）的operator。这里的检查规则比较简单，仅仅实现了基于char的比较，实际上过于严格，以至于阻止了用户定义unary-这样的合法要求。后续细化保护规则后(拆分运算符和受保护的字符两种类型，对运算符区分binary和uary类型)，即可支持unary-。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现过程中发现原示例确实精炼，仅用很少的代码便实现了用户自定义operator的功能。但是，其精炼的代价是该功能仅仅具有演示价值而几乎没有实用价值。<br>例如，原示例没有在lexer做token分层，parser会直接读取输入的char。这样一来lexer可以非常非常简单。并且，在新增语法功能时，parser由于可以直接穿透处理char，需要新增的配合代码也很少。<br>但是这样的设计导致代码维护困难，parser中要直接处理token拆分逻辑，一旦语法变复杂，新增功能或更改已有逻辑(直接操作char的地方会很多)就会很困难。<br>另外，原示例没有错误防护的逻辑，这会导致用户犯错很难定位原因。</p>
<p>实现过程中针对前面扩展中提出的问题，一一进行了改进。详细情况可参考扩展问题一节中的描述。<br>从实现后的实际情况看，改进引入了相当多的额外代码，工作量较大。作为示例，相较于引入大量的细节流程，原作者使用精简的方案确实是更好的权衡（示例丧失了扩展为真正可实用编译器的潜力，但仍然展现了主要的原理，解决了核心问题）。</p>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>1 命名时没有限制operator是否能是常规字符(如abc,123等)，会否产生静默的关键字冲突？<br>原示例几乎没有对自定义operator做错误防护。这将导致用户错误定义operator，很难察觉和定位到根因。<br>如下所示，覆盖内置操作符的优先级和语义将导致二义性和混乱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def binary + 80 (a b) a+b; </span><br><span class="line">ready&gt; Read function definition:define double @&quot;binary+&quot;(double %a, double %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp &#x3D; fadd double %a, %b</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; 1+2*3;</span><br><span class="line">ready&gt; Evaluated to 9.000000</span><br></pre></td></tr></table></figure>

<p>定义保留字符’,’，parser无法理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def unary , (a) a+1;</span><br><span class="line">ready&gt; Read function definition:define double @&quot;unary,&quot;(double %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp &#x3D; fadd double %a, 1.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line">ready&gt; def xy3(a) a+,a;</span><br><span class="line">ready&gt; Error: unknown token when expecting an expression</span><br><span class="line">ready&gt; Error: Unknown variable name</span><br></pre></td></tr></table></figure>

<p>定义保留字符’(‘，parser无法理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def unary ( (a) a+1;</span><br><span class="line">ready&gt; Read function definition:define double @&quot;unary(&quot;(double %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp &#x3D; fadd double %a, 1.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line">ready&gt; def xy4(a) a+(1  </span><br><span class="line">ready&gt; ;</span><br><span class="line">Error: expected &#39;)&#39;</span><br></pre></td></tr></table></figure>
<p>为了避免这些错误，在实现时专门针对binary/unary的名称做了正确性校验(verify_operator_sym函数)。<br>在错误第一现场阻止错误，并给出清晰的提示。</p>
<p>2 考虑如何处理两个特殊字符组成的操作符，如==　!=等。<br>原示例由于使用了char来作为operator的opcode，实际上就无法支持两字符操作符。但使用单char作为operator的opcode，大大简化了构建operator token的难度。因为只需要在parser中按需读出一个char就可以，无需考虑在lexer中如何正确切分的问题。<br>为了支持!= 和==等显然有意义的两字符operator，本次实现时在lexer中添加了一个map查找机制，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur_token == TOKEN_BINARY || cur_token == TOKEN_UNARY)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (install_user_defined_operator(input_stream, cur_char))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get_user_defined_operator(input_stream, cur_char))</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>install_user_defined_operator函数，在binary和unary关键字后识别并注册(就是插入到map中)用户自定义的operator token。<br>get_user_defined_operator中就可以查找已经注册的用户自定义operator，并给出正确的token类型（用户自定义unary或者binary）。</p>
<p>3 示例中的自定义operator是否能作为库使用？如果不能应该如何改进？<br>从实现原理上来说，因为operator 也是在proto中解析的，与函数一样。<br>所以自定义的operator只要遵循先extern申明，再引用的规则，就可以以库的方式正常使用(定义在单独的库文件中，使用时链接二进制文件)。<br>但是，原示例没有考虑容错问题。<br>parser在工作时是按照extern声明的优先级工作。如果定义时的优先级和extern时的不一致，则程序的逻辑将静默改变。用户要发现这样的问题可能很困难（这个和C中没有正确包含头文件的情况类似）。<br>为了解决这个问题，参考C++的方法，把prio作为一个强制信息加入到binary/unary函数的名称中。这样一旦extern声明和def的定义不一致，链接时会找不到函数定义。用户将不能得到可工作（但逻辑错误）的二进制文件。</p>
<h3 id="实现中遇到的问题"><a href="#实现中遇到的问题" class="headerlink" title="实现中遇到的问题"></a>实现中遇到的问题</h3><p>1 prototype_tab的key从string切换到string_view后，遇到了内存数据错误的问题。详细记录如下。<br>使用string_view作为map的key时，我们调用了tab.insert(make_pair(a_string, my_val));。原以为string会自动转为string_view，tab中的key(string_view)数据应该指向a_string。实际发现key的数据指向了一个insert所在的函数栈。<br>使用下面的小型测试用例即可复现出问题，pair中的key并不是指向我们希望的全局数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_view</span><span class="params">(pair&lt;string_view, <span class="keyword">int</span>&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"value:"</span>&lt;&lt; p.first.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"address:"</span> &lt;&lt; (<span class="keyword">void</span>*)p.first.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">global</span><span class="params">(<span class="string">"abc"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"value_global:"</span> &lt;&lt; global.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"address_global:"</span> &lt;&lt; (<span class="keyword">void</span>*)global.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        test_view(make_pair(global,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用g++ save-temps -fdump-tree-all-details -std=c++17编译上面的代码，可以比较清楚地看出问题。<br>这里的核心错误在于：<br>make_pair是一个模板函数，(为了提供泛型能力)它并不知道（或者提供这个约束）第一个参数应该是string_view。当我们提供一个string作为第一个参数时，test_view(make_pair(global,1));的调用并没有变成我们希望的test_view(make_pair((string_view)global,1))。而是变成了如下的序列。<br>tmp_pair = make_pair&lt;string, int&gt;(global, 1);<br>tmp_pair_to_call = pair&lt;string_view, int&gt; (tmp_pair);<br>test_view(tmp_pair_to_call);<br>这样传到test_view中pair中的string_view实际上指向栈上创建的临时变量。一旦tmp_pair所在的函数return，string_view中的key就乱掉了（use after free）。</p>
<p>从这次经历看string_view确实是非常容易出错的点，使用时需要特别谨慎。参考 <a href="https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/" target="_blank" rel="noopener">https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/</a> 的如下示例，string_view允许指向临时对象，这确实很容易导致错误，并且很难发现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"Hellooooooooooooooo "</span>;</span><br><span class="line">  <span class="built_in">std</span>::string_view sv = s + <span class="string">"World\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 切换到clang8编译器后，优化LLVM-IR时程序段错误。<br>google搜索到了下面的邮件，这是一个gcc/clang的abi兼容性问题。<br><a href="http://lists.llvm.org/pipermail/llvm-dev/2019-January/129567.html" target="_blank" rel="noopener">http://lists.llvm.org/pipermail/llvm-dev/2019-January/129567.html</a><br>需要将llvm库用clang重新编译（或者升级到最新的llvm）。<br>升级到最新的llvm代码后确实解决了该问题。</p>
<p>3 升级到最新的llvm后，遇到了asan报大量indirect leak问题。<br>仔细检查代码后，发现llvm_optimizer::optimize_function等函数中，<br>使用了createTargetMachine创建的TargetMachine *。<br>添加了delete TargetMachine *的语句后，leak告警消失。<br>老版本为何没报leak，暂时没有进一步核查。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjblog.github.io/2020/02/21/llvm_tr6_user_defined_operator/" data-id="ckg246lql001852fa980q0zu5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&amp;laquo; __(&#39;prev&#39;)</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__(&#39;next&#39;) &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GRAALVM/" rel="tag">GRAALVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/" rel="tag">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM-STUDY/" rel="tag">LLVM_STUDY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/env/" rel="tag">env</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 20px;">AI</a> <a href="/tags/GRAALVM/" style="font-size: 10px;">GRAALVM</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/LLVM-STUDY/" style="font-size: 20px;">LLVM_STUDY</a> <a href="/tags/env/" style="font-size: 10px;">env</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/25/graal_license/">graalvm license分析</a>
          </li>
        
          <li>
            <a href="/2020/09/18/eclipse_theia/">eclipse theia 研究</a>
          </li>
        
          <li>
            <a href="/2020/07/28/first-test/">ubuntu 16.04下驱动TP-LINK TL-WDN6200H免驱版无线网卡</a>
          </li>
        
          <li>
            <a href="/2020/07/09/tvm_ir_debug/">tvm 构建结果调试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/arduino_dev/">arduino开发体验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Ma Jiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>